%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{O cálculo lambda}

\subsection{Visão geral}

No início do século XX, tornou-se necessária, na matemática, uma definição 
precisa para a noção intuitiva do processo computacional. Diversos modelos foram
propostos para resolver este problema. Entre eles está o cálculo lambda,
proposto por Alonzo Church \cite{lambda_first}, em 1936. Inicialmente, o cálculo
fazia parte de um sistema maior, proposto para servir como uma base
formal para o estudo das fundações da matemática. Porém, devido a
inconsistências neste sistema, Alonzo Church foi obrigado a abrir mão de seu
objetivo inicial, separou a parte utilizável do sistema e formou o que hoje
conhecemos como cálculo lambda.

O grande diferencial deste cálculo está em sua expressividade, com poder
computacional equivalente ao da Máquina de Turing, e sua simplicidade,
demonstrada por sua gramática concisa e poucas regras. A ideia central deste
consiste em simular a criação e aplicação de funções. Diferentemente da noção
usual no trabalho matemático, as funções neste sistema são chamadas "anônimas",
pois são definidas tendo em vista somente seus argumentos e o resultado. Como
exemplo, uma função simples como: "$double(x) = 2*x$" \ é definida anonimamente como
"$\lambda x.\ 2*x$". É utilizada também uma notação especial para a aplicação de
funções, denotada como "$ (\lambda x.\ 2*x)$  $3$".

É importante notar que os exemplos acima não são representados exatamente desta
maneira. Como dito anteriormente, o sistema possui uma gramática simples, e
todas as noções, inclusive números e operações, devem ser definidas com base em
abstrações e aplicações. A gramática do cálculo lambda pode ser descrita
sucintamente como:

\[ \tau := x\ |\ \lambda y.\tau\ |\ \tau \tau \]

Onde $\tau$ representa um termo, e \textbf{x} representa uma variável livre. A
variável \textbf{y} no segundo caso é chamada de \textit{variável ligada},
pois suas ocorrências em $\tau$ estão associadas à abstração. 
O conjunto de variáveis livres de \emph{t} é denotado por \emph{fv(t)}. O processo
computacional é simulado no sistema através da regra de $\beta$-redução,
definida como:

\[ (\lambda x.t)\ u \rightarrow_{\beta} t\{x/u\} \]

Note que t\{x/u\} é uma \textit{meta-operação}, definida pela substituição das
ocorrências da variável \textbf{x}, no termo \textbf{t}, pelo termo \textbf{u}.
Abaixo, alguns exemplos de $\lambda$-termos.

\begin{itemize}
    \item A função identidade pode ser representada pelo termo $ (\lambda x. x) $.
        É fácil ver a correspondência na seguinte redução: $ (\lambda x.x) u
    \rightarrow_\beta x \{x/u\} \rightarrow u $. 
    \item A função constante pode ser representada pelo termo $ (\lambda x. M) $,
        onde M é um termo qualquer, tal que $x \notin fv(M)$.
        É fácil ver a correspondência na seguinte redução: $ (\lambda x.M) u
    \rightarrow_\beta M \{x/u\} \rightarrow M $. 
    \item Por último, podemos representar uma função que recebe dois termos e
        retorna o primeiro, como $ (\lambda x. \lambda y. x)$. Sua aplicação é
        reduzida da seguinte maneira: $ ((\lambda x. \lambda y. x)\ M)\ N)
    \rightarrow_\beta ((\lambda y. x) \{x/M\} N) \rightarrow (\lambda y. M) N
    \rightarrow_\beta M \{y/N\} \rightarrow N$, com \textbf{x,y} não ocorrendo 
    livres em M ou N.
\end{itemize}



A partir destas definições, várias propriedades sobre o sistema podem ser
estudadas. Entre elas, é importante ressaltar as noções de \textit{forma
 normal} e de \textit{confluência}:

\begin{description}
    \item[Forma normal:] Um termo \textbf{t} é dito estar em forma
    normal quando não existe \textbf{t'} tal que $ t \rightarrow_\beta t' $. 
    É possível demonstrar que nem todo termo que pode ser expressado no sistema
    possui uma forma normal. Como exemplo, observe que $ (\lambda x.x\ x)\ (\lambda
    x.x\ x) \rightarrow_\beta (\lambda x.x\ x)\ (\lambda x.x\ x) $. Um termo é
    dito normalizável quando existe uma estratégia de redução que leva a uma
    forma normal. O termo é \emph{fortemente normalizável} se toda estratégia
    leva à forma normal. A noção de normalização é especialmente importante,
    pois indica se um termo pode ou não terminar quando for avaliado, o que é de
    grande interesse no estudo computacional.

    \item[Confluência:] Um sistema de reescrita, tomando como exemplo o cálculo
    lambda, é dito confluente se, para todo termo \textbf{t}, se $ t
    \rightarrow_\beta t' $ e $ t \rightarrow_\beta t'' $, então deve existir
    um termo \textbf{u} tal que \textbf{t'} e \textbf{t''} reduzem para ele,
    em zero ou mais passos da $\beta$-redução.  Os termos \textbf{t'} e
    \textbf{t''} são ditos \textit{$\beta$-equivalentes}.  A propriedade de
    confluência pode ser entendida, essencialmente, como uma garantia que a
    ordem que as reduções são feitas dentro de um termo não afetam o
    resultado final do processo.
\end{description}

Outro ponto importante a ser mencionado é a noção de $\alpha$-equivalência de
termos. Um termo $(\lambda x. t)$ é dito $\alpha$-equivalente a $(\lambda y. u)$
se $ t\{x/y\} = u $. Esta noção captura a ideia de que a escolha do nome das
variáveis ligadas não importa em geral, sendo o real objeto de interesse a
estrutura do termo. Esta definição é útil para evitar certos problemas, como por
exemplo o de \textit{captura de variáveis livres}. No exemplo:

\[ ((\lambda x.\ x\ y)\ u)\{y/x\},\ x\ \neq\ y,\ y  \notin fv(u) \]

Observe que, reduzindo a aplicação antes de aplicar a substituição, temos:


\[ ((\lambda x.\ x\ y)\ u)\{y/x\} \rightarrow_\beta ((x\ y)\{x/u\}\{y/x\})
\rightarrow (u\ y)\{y/x\} \rightarrow (u\ x) \]

Mas, fazendo a substituição imediatamente, temos:

\[ ((\lambda x.\ x\ y)\ u)\{y/x\} \rightarrow ((\lambda x.\ x\ x) u)
\rightarrow_\beta (x\ x)\{x/u\} \rightarrow (u\ u) \]

Veja que isto muda completamente o funcionamento do termo. A variável \textbf{x}
na substituição não é a mesma da que está ligada na abstração! Isto pode causar
vários problemas inesperados, como, por exemplo, a perda da normalização do
termo. Se o termo \textbf{u} for da forma $(\lambda z. z z)$, ao realizar a
substituição imediatamente, obtemos o termo $(\lambda z. z z)\ (\lambda z. z z)$,
que, como dito anteriormente, não termina.
Para evitar este problema, podemos renomear a variável ligada \textbf{x}, antes
da substituição, por uma variável nova, de maneira a obter um termo
$\alpha$-equivalente e podendo então realizar a substituição sem modificar a
estrutura do termo.

\subsection{Representação de $\lambda$-termos}
\label{sub:int_lnr}

Como dito anteriormente, o cálculo lambda é usado como modelo teórico para
linguagens funcionais. A noção de $\alpha$-equivalência, apesar de útil, pode ser
muito custosa em uma implementação prática. Por este motivo, foram propostas
algumas representações diferentes de termos, de modo a evitar a necessidade do
renomeamento de variáveis. 

Uma das primeiras, e mais importantes, tentativas de resolver o problema da
$\alpha$-conversão é a notação utilizando indices de De Bruijin. Nela, são
utilizados números naturais para representar as variáveis. Cada número
representa a quantidade de abstrações no escopo da ocorrência. Números que
ultrapassam esta quantidade representam variáveis livres. A gramática pode ser
definida como:

\[ \tau := n\ |\ \lambda . \tau\ |\ \tau \tau \]

Onde \textit{n} representa um número natural, a partir do 1. Exemplos de termos
nesta notação incluem a identidade $(\lambda. 1)$, a função constante $(\lambda.
u)$, com \textbf{u} não contendo 1 como índice livre, e um termo com índice
livre, como $((\lambda.2) u)$. Apesar de sua praticidade de implementação, esta
notação se afasta muito da utilização do cálculo no papel, além de não separar
sintaticamente variáveis livres e ligadas.

Uma solução para estes problemas é usar a \textit{locally nameless
representation}, usada para representar os $\lambda$-termos neste trabalho.
A gramática do sistema é modificada parcialmente:

\[ \tau := x\ |\ \lambda . \tau\ |\ \tau \tau \]

Observe que a abstração também não carrega uma variável ligada. Ao invés disso,
são usados índices (que podem ser números naturais, como em de Bruijin) para
representar estas variáveis. A meta-substituição deve então ser adaptada para
levar em conta estes índices, como no exemplo:

\[ (\lambda.\ 1) \{0/t\} \rightarrow ( \lambda. (1 \{1/t\}) ) \]

Note que o índice a ser substituído foi incrementado quando a substituição entra
na abstração, de modo a corresponder à variável correta a ser substituída. 
A operação de substituição pode ser melhor definida como:

\begin{empheq}[box=\fbox]{align*}
    \{k \rightarrow x\} i\ \ \ \  & \equiv\ \ x,\ se\ (i = k);\ i,\ c.c\\
    \{k \rightarrow x\} y\ \ \ \  & \equiv\ y\\
    \{k \rightarrow x\} (t\ u)\ \ \ \  & \equiv\ (\{k \rightarrow x\}t\ \{k
    \rightarrow x\}u)\\
    \{k \rightarrow x\} (\lambda . t) \ \ \ \  & \equiv\ 
    (\lambda . \{k+1 \rightarrow x\}t)
\end{empheq}



As variáveis livres continuam sendo representadas da mesma maneira. Esta
representação foi detalhada por Arthur Charguéraud em \cite{chargueraud}, junto
com provas de seu bom funcionamento e um framework para sua utilização em Coq.
Entraremos agora em alguns detalhes do uso desta notação, descritos em
\cite{chargueraud}, já que ela tem um interesse especial neste trabalho.

Na notação usual, quando queremos estudar o corpo de uma abstração $(\lambda x.
t)$, podemos trabalhar diretamente com o termo \textit{t}. Porém, nesta nova
representação, a abstração tem a forma $(\lambda . t)$, e é necessário que seja
fornecida uma variável \textit{x} para se trabalhar com o corpo. Esta operação é
chamada \emph{abrir o termo} \textit{t} com \textit{x}, e será representada por
$t^{x}$. Mais precisamente, a abertura do termo $(\lambda . t)$ cria uma cópia
de \emph{t} onde todas as ocorrências do índice ligado à abstração mais externa
são trocados pela variável \emph{x}. Como exemplo, abrir a abstração $(\lambda.
(0\ y))$ com \emph{x} nos dá o termo $(x\ y)$. A operação de abrir o termo deve
ajustar o índice a ser mudado à medida que entra no termo. Assim, podemos usar a
já definida operação de substituição, diretamente com a variável \emph{x}, para
realizar a abertura. Temos, então, $t^{x} \equiv t\{0/x\}$.

Similarmente, podemos querer abstrair todas as ocorrências de \emph{x} no termo
\emph{t}, construindo então o termo $(\lambda x. t)$. Com a nova notação, é
necessário definir uma operação que substitui todas as ocorrências de \emph{x}
pelo índice 0, antes de adicionar a abstração. Esse processo é chamado
\emph{fechar o termo}, representado por $ ^{\textbackslash x}t$. Assim, para
construir a abstração de maneira equivalente, fazemos $(\lambda .
^{\textbackslash x}t)$. Podemos definir a operação de fechamento como $
^{\textbackslash x}t \equiv \{0 \leftarrow t\}$, onde esta nova substituição é
definida como:

\begin{empheq}[box=\fbox]{align*}
    \{k \leftarrow x\} i\ \ \ \  & \equiv\ i\\
    \{k \leftarrow x\} y\ \ \ \  & \equiv\ \ 0,\ se\ (x = y);\ y,\ c.c\\
    \{k \leftarrow x\} (t\ u)\ \ \ \  & \equiv\ (\{k \leftarrow x\}t\ \{k
    \leftarrow x\}u)\\
    \{k \leftarrow x\} (\lambda . t) \ \ \ \  & \equiv\ 
    (\lambda . \{k+1 \leftarrow x\}t)
\end{empheq}

Como dito anteriormente, esta representação possui termos que contém
\emph{índices livres}. Tais termos não possuem correspondentes no sistema
original, pois os índices não estão ligados a nenhuma abstração e não
representam variáveis livres. Assim, precisamos tomar cuidado para evitar
trabalhar com termos com tais índices, já que estes não são nosso objeto de
interesse. Para isto, chamaremos um termo sem índices livres de \emph{localmente
fechado}.

Existem duas maneiras de conferir se um termo é localmente fechado. A primeira
consiste em andar pela estrutura do termo, abrindo cada abstração com uma nova
variável. Desta maneira, se o termo for de fato fechado, nunca encontraremos um
índice. A segunda abordagem consiste em analizar diretamente os índices do termo,
checando, para cada um deles, se o seu valor é menor ou igual ao número de
abstrações que o rodeiam.

A primeira opção dá lugar a uma definição natural de um predicado, denotado por
\emph{lc\ t} indicando que o termo é localmente fechado. Com apenas três regras
de inferência, podemos facilmente fazer uma análise mais formal da propriedade
de ser localmente fechado, sendo bastante útil em provas.

\begin{mathpar} 
    \inferrule*[Right=lc\_fvar]{  }
    {lc(x)}
    \and
    \inferrule*[Right=lc\_app]{lc\ t1 \\ lc\ t2}
    {lc(t1\ t2)}
    \and
    \inferrule*[Right=lc\_abs]{\forall x \notin L,\ lc\ (t^{x})}
    {lc(\lambda. t)}
\end{mathpar}

A premissa $\forall x \notin L$ no caso da abstração captura a ideia de \emph{x}
ser uma variável nova, pois podemos tomar o conjunto L, sempre finito, como
sendo o conjunto de variáveis já usadas e, assim, sempre ter uma escolha nova de
\emph{x}.

A segunda abordagem tem um caráter mais naturalmente computacional, dando lugar
a uma função recursiva para conferir se um termo é localmente fechado. Tal
função vai navegando pelo termo, entrando em seus subtermos, guardando um
contador. Quando entrar em uma abstração, a função incrementa tal contador. Ao
encontrar um índice, basta conferir se ele é menor que o contador. Assim, a
função pode ser definida como a seguir.

\begin{empheq}[box=\fbox]{align*}
    lc\_at\ k\ (i)\ \ \ &\equiv\ i<k \\ 
    lc\_at\ k\ (x)\ \ \ &\equiv\ True \\ 
    lc\_at\ k\ (t1\ t2)\ \ \ &\equiv\ (lc\_at\ k\ t1)\ \&\ (lc\_at\ k\ t2) \\ 
    lc\_at\ k\ (\lambda. t1)\ \ \ &\equiv\ (lc\_at\ k + 1\ t1)
\end{empheq}

Dizemos que o termo \emph{t} é localmente fechado se a função \emph{(lc\_at 0
t)} retorna \textbf{True}.  Não é difícil provar a equivalência de ambas as
definições, ou seja, que vale $lc\ t\ \iff\ (lc\_at\ 0\ t)\ =\ True$.

Ambas as implicações possuem uma demonstração simples. Para o caso em que $lc\ t
\rightarrow (lc\_at\ 0\ t)\ =\ True$, podemos fazer uma indução no predicado
\emph{lc}. O único subcaso que não sai imediatamente é o da abstração, que pode
ser facilmente resolvido se observarmos que um termo $t^{x}$ é fechado a um
nível k se, e somente se, \emph{t} é fechado a nível k + 1.

A volta, ou seja $lc\ t \leftarrow (lc\_at\ 0\ t)\ =\ True$, se faz por uma
indução na estrutura do termo \emph{t}. Novamente, o caso da abstração merece um
cuidado especial, mas ainda sai de maneira simples, escolhendo o conjunto L como
sendo exatamente o conjunto de variáveis livres de \emph{t}.

Vale a pena ressaltar duas outras equivalências, referentes às noções de
abertura e fechamento de termos. Temos:

\begin{empheq}[box=\fbox]{align*}
    ^{\setminus x}(t^{x})\ &=\ t,\ se\ x\ \notin\ fv(t) \\
    (^{\setminus x}t)^{x}\ &=\ t,\ se\ vale\ (lc\ t)
\end{empheq}


Estas definições serão extremamente importantes ao decorrer do trabalho e podem
ser citadas com frequência.

Para mais informações a respeito do cálculo lambda, veja \cite{barendregt}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\



\section{Substituições explícitas}

\subsection{Motivação e histórico}

Sabemos que a ordem em que as reduções são feitas não altera a forma normal do
termo, mas isto não significa que não existem vantagens em se adotar certas
estratégias na normalização. Como exemplo, observe os seguintes casos:

\[ ((\lambda.\ x) t) \{0/y\} \rightarrow ((\lambda.\ x\{1/y\})\ t\{0/y\}) 
    \rightarrow ((\lambda.\ x) t') \rightarrow (x\{0/t\}) \rightarrow x
\]

\[ ((\lambda.\ x) t) \{0/y\} \rightarrow (x\{0/t\}) \{0/y\} 
    \rightarrow x \{0/y\} \rightarrow x \]

Veja que, na segunda abordagem, evitamos uma operação potencialmente custosa de
realizar uma substituição em um termo \emph{t} que seria imediatamente
descartado. Infelizmente, o uso da meta-operação nos impede de realizar este
tipo de manipulação, pois a substituição não faz parte da sintaxe do sistema.

Na implementação de linguagens de programação, a substituição muitas vezes é
"atrasada", de modo a evitar computações desnecessárias. Para aproximar o modelo
teórico de seu correspondente prático, podemos tentar fracionar a operação de
substituição em partes atômicas, de maneira a permitir uma manipulação simbólica
mais precisa. 

Por este motivo, várias tentativas de se formalizar a noção de substituição,
dando então espaço para o formalismo conhecido como \textit{substituição
explícita}. A princípio, podemos tentar extender a gramática de termos da
seguinte maneira:

\[ \tau := x\ |\ \lambda x.\tau\ |\ \tau \tau\ |\ \tau[x/\tau]\ \]

Podemos então espelhar o funcionamento da meta-substituição através de regras de
redução no novo cálculo, gerando o sistema conhecido como $\lambda$x.

\begin{table}[h]
\begin{empheq}[box=\fbox]{align*}
    (\lambda x.\ t)\ u\ \ \ &\rightarrow\ t[x/u] \\
    x[x/u]\ \ \             &\rightarrow\ u \\
    y[x/u]\ \ \             &\rightarrow\ y,\ se\ x\ \neq\ y \\
    (t\ u)[x/v]\ \ \        &\rightarrow\ t[x/v]\ u[x/v] \\
    (\lambda y.\ u)[x/v]\ \ &\rightarrow\ (\lambda y.\ u[x/v])
\end{empheq}
    \caption{Regras do sistema $\lambda$x}
\end{table}

O sistema $\lambda$x corresponde ao comportamento mínimo que se espera de um
cálculo com substituições explícitas. Porém, existem outras propriedades
interessantes que podem ser adicionadas ao sistema e, em consequência disto,
vários outros modelos foram propostos, como o $\lambda_\sigma$, $\lambda_{ws}$,
$\lambda$lxr, entre outros. 

Um problema que pode acontecer em sistemas com substituição explícita é a perda
da preservação da normalização forte (\textbf{PSN}), que pode ser definida como:

\begin{description}
    \item[PSN:] Se $\lambda$z é um cálculo baseado no cálculo $\lambda$, deve
        valer a seguinte afirmação. Se \emph{t} é um $\lambda$-termo fortemente
        normalizável, então seu correspondente em $\lambda$z também o é neste
        novo sistema.
\end{description}

Este tipo de problema é especialmente comum em cálculos de substituições
explícitas que possuem a propriedade de composição de substituições.
Essencialmente, dado um termo $t[x/u][y/v]$, podemos compor as duas
substituições, de maneira a reduzir a segunda substituição antes da primeira.
Como resultado, teríamos o termo $t[y/v][x/u[y/v]]$. 

Várias estratégias são usadas para se tentar garantir a propriedade \emph{PSN}
do sistema, como utilização de marcas em termos, restrição de composições ou
reduções dentro de substituições explícitas, definições de classes de
equivalências, entre outros. Para uma visão geral do histórico de cálculos de
substituições explícitas, veja \cite{es_overview}.

A seguir, veremos um sistema que propõe uma maneira de se compor tais
substituições sem perder a propriedade \emph{PSN}.



\subsection{O sistema $\lambda$ex}
\label{sub:int_lex}


Com este objetivo em mente, foi proposto em \cite{delia} o
sistema $\lambda$ex. Este sistema será repetido aqui, e um maior entendimento
pode ser obtido na fonte original. São introduzidas várias mudanças, a começar
pela gramática: 

\[ \tau := x\ |\ \lambda x.\tau\ |\ \tau \tau\ |\ \tau[x/\tau]\ \]
\

\begin{table}[h]
    
\begin{empheq}[box=\fbox]{align*}
    x[x/u]\ \ \             &\rightarrow_{Var}\ u \\
    t[x/u]\ \ \             &\rightarrow_{Gc}\ t    & se\ \emph{x} \notin fv(t)\\
    (t\ u)[x/v]\ \ \        &\rightarrow_{App}\ t[x/v]\ u[x/v] \\
    (\lambda y.\ u)[x/v]\ \ &\rightarrow_{Lamb}\ (\lambda y.\ u[x/v])\\
    t[x/u][y/v]\ \ \        &\rightarrow_{Comp}\ t[y/v][x/u[y/v]] & se\ y\ \in
    fv(u) \\ 
    (\lambda x.\ t)\ u\ \ \ &\rightarrow_B\ t[x/u]
\end{empheq}
    \caption{Regras de redução}
    \label{table:red_lambex}

\end{table}

A nova construção é chamada \textit{substituição explícita}, e é o que permite as
manipulações sintáticas com substituições no cálculo. Como consequência desta
mudança, novas regras de redução são definidas, como mostrado na tabela
\ref{table:red_lambex}.  As 5 primeiras regras formam a relação $\rightarrow_x$,
e o acréscimo da última forma a relação $\rightarrow_{Bx}$. 

Observe que, devido ao acréscimo das substituições explícitas, é possível
definir termos que possuem uma sintaxe distinta, diferindo apenas na permutação
de substituições independentes, e que constiturem o mesmo
$\lambda$-termo no sistema original. Um exemplo simples pode ser visto a seguir.

\[ (0\ 1) \{0/x\}\{1/y\} = (0\{0/x\}\ 1\{1/y\}) = (x\ y) =  (0\ 1) \{1/y\}\{0/x\} \]
\[ (0\ 1) [0/x][1/y] \neq  (0\ 1) [1/y][0/x] \]

Onde a noção de igualdade usada é a sintática.

Assim, é necessário tornar o novo sistema
equacional, adicionando uma relação de equivalência:

\[ t[x/u][y/v] =_C t[y/v][x/u] \ \ \ \ \ se\ y \notin fv(u)\ \&\ x \notin fv(v)\] 

A relação de equivalência $=_e$ é formada com a junção de $=_C$ e
$\alpha$-equivalência. As relações $\rightarrow_{ex}$ e $\rightarrow_{\lambda
    ex}$ são definidas como:

\[t\ \rightarrow_{ex}\ t'\ \iff\ \exists\ s,s'\ t.q.\ t\ =_{e}\ s\
    \rightarrow_x\ s'\ =_e\ t' \]
\[t\ \rightarrow_{\lambda ex}\ t'\ \iff\ \exists\ s,s'\ t.q.\ t\ =_{e}\ s\
    \rightarrow_{Bx}\ s'\ =_e\ t' \]

Estas relações serão amplamente utilizadas ao decorrer deste trabalho. 
O foco principal é a formalização da propriedade \textbf{IE} do sistema, que
pode ser entendida intuitivamente da seguinte maneira: Dados \textbf{t},
\textbf{u} tais que \emph{u} e \emph{t\{x/u\}} são fortemente normalizáveis
no sistema, então o correspondente utilizando substituições explícitas,
\emph{t[x/u]} também será. Ou seja, a normalização da substituição implícita
implica a normalização da explícita.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{O assistente de provas Coq} 
\subsection{Motivação}

Assistentes de provas são sistemas computacionais que permitem aos usuários
realizar provas e definições em um computador. Neles, o usuário pode construir
toda sua teoria matemática em uma linguagem em que o sistema seja capaz de
verificar automaticamente. Ou seja, a principal motivação por trás de um
assistente de prova é verificar formalmente as provas de uma teoria. Apesar de
já existir um processo humano de verificação, muitas vezes ocorrem erros neste
processo, e provas que foram aceitas numa primeira avaliação são descobertas
problemáticas algum tempo depois. Como exemplo, podemos citar o teorema das
quatro cores \cite{four_colour}, que desafiou matemáticos por anos e foram
apresentadas falsas provas diversas vezes. Eventualmente, o teorema foi provado
em um assistente de prova e hoje sua corretude é aceita.

Mas, então, o que exatamente significa uma prova? Uma prova normalmente é
definida como o processo de se estabelecer a validade de alguma afirmação. Na
matemática, as provas costumam exigir uma clareza e rigor mais extremo, de modo
a se tornar indiscutível quando analizada com cuidado. Porém, matemáticos são
humanos e, infelizmente, cometem erros. Com isto em mente, foi definida uma
noção ainda mais forte de prova, chamada \emph{prova formal}.

Uma prova formal é uma sequência finita de sentenças tal que cada uma delas ou é
um axioma, uma suposição ou é derivada diretamente das sentenças anteriores
através das chamadas regras de inferência. A vantagem do rigor das provas
formais é que conferí-la se torna um processo muito mais simples, sendo
necessário apenas confirmar de onde vem cada uma das sentenças.

Por este motivo, provas formais são comumente construídas e verificadas pelos
assistentes de prova. Ao utilizar a linguagem do assistente, ele aos poucos
constrói a sequência de sentenças e simultaneamente checa sua validade. Porém,
isto gera outra dúvida: Por que confiar nos assistentes de prova?


\begin{description}
    \item[Lógica do assistente:] Os assistentes de prova em geral possuem uma
        teoria forte no qual são baseados. Em geral, existe um sistema
        matemático independente de implementação que pode ser estudado e
        verificado anteriormente.
    \item[Checagem do assitente:] O assistente em si é, também, um programa. Assim,
        podemos analizar seus algoritmos, demonstrar que só é possível provar
        teoremas derivados no sistema lógico interno e testar seu funcionamento
        como um programa normal.
    \item[Critério de De Bruijin:] Muitos assistentes de prova criam um
        \emph{objeto de prova}, uma prova formal independente do sistema que
        pode ser checada tanto por outro programa, quanto por um matemático
        interessado.  
\end{description}

Recentemente, existe um grande número de matemáticos interessados em assistentes
de prova, buscando construir uma teoria consistente para o uso destes e
produzindo o software necessário para facilitar seu uso. Em especial, um dos
assistentes com maior uso é o chamado Coq, a ser apresentado a seguir.

Para uma visão geral sobre o histórico e uso de assistentes de prova, veja
\cite{proof_assist}. 

\subsection{A ferramenta}

Neste trabalho, usaremos o Coq, um assistente de provas que está em
desenvolvimento desde 1983, em vários institutos de pesquisa franceses. O Coq
provê um rico ambiente para o desenvolvimento de um raciocínio formal checado
automaticamente. O núcleo do sistema é um checador de provas simples que garante
que apenas passos válidos de dedução são efetuados. Além deste núcleo, o
ambiente provê diversas táticas para facilitar a construções de provas, junto
com uma vasta biblioteca de definições e teoremas comuns.

A ferramenta vem acompanhada de uma linguagem de programação funcional, com
tipos dependentes. É através desta linguagem que podemos criar as definições e
provar os lemas de nossa teoria. Ela é baseada no Cálculo de Construções
Indutivas, uma extensão do cálculo lambda que serve como modelo teórico para o
sistema. O processo de se verificar a corretude de uma prova em Coq se reduz ao
problema de \emph{checagem de tipos}. A seguir, será feita uma introdução à
sintaxe e o funcionamento da ferramenta, baseada em tutoriais disponibilizados
na página oficial do sistema, em \cite{coq} e \cite{coq2}.


Os objetos de Coq podem ser divididos em duas categorias, \emph{Prop} e
\emph{Type}. A categoria \emph{Prop} é a das proposições bem formadas. Um
exemplo de proposição na linguagem seria:

\begin{lstlisting}[basicstyle=\small]
    forall A B : Prop, A -> (A \/ B).
\end{lstlisting}

Predicados podem ser definidos indutivamente, como a seguir.

\begin{lstlisting}[basicstyle=\small]
    Inductive even : N -> Prop :=
    | even_0 : even 0
    | even_S n : odd n -> even (n + 1)
    with odd : N -> Prop :=
    | odd_S n : even n -> odd (n + 1).
\end{lstlisting}

Predicados também podem ser feitos como definições diretas, como:

\begin{lstlisting}[basicstyle=\small]
    Definition sqr(x : N) := exists z, z*z = x.
\end{lstlisting}

Assim, podemos utilizar estes predicados como propriedades de algum objeto,
provando algo como \emph{even(2)} ou \emph{sqr(4)}.

\emph{Type} é a categoria de estruturas matemáticas e estruturas de dados.
Alguns exemplos de tipos são:

\begin{lstlisting}[basicstyle=\small]
    Z x Z -> Z
\end{lstlisting}

Tipos também podem ser definidos indutivamente:

\begin{lstlisting}[basicstyle=\small]
    Inductive nat : Set :=
    | 0 : nat
    | S : nat -> nat.
\end{lstlisting}

Neste caso, elementos do tipo \emph{nat} são: 0, S ( 0 ), S ( S ( 0 ) ), etc.

O desenvolvimento de provas em Coq é feito através de uma linguagem de provas,
que permite um processo guiado pelo usuário. Ao utilizar uma tática, o usuário
está construindo os objetos de prova. Por exemplo, a tática
\texttt{intro n}, onde \emph{n} é do tipo \texttt{nat}, constrói o termo (com um
buraco):

\begin{lstlisting}[basicstyle=\small]
    fun (n:nat) => _
\end{lstlisting}

Onde \_ representa um termo que irá ser construído futuramente, utilizando
outras táticas. Um exemplo de proposição simples que podemos querer provar é
\texttt{forall A : Prop, A -> A}. Provamos isto da seguinte maneira:

\begin{lstlisting}[basicstyle=\small]
    Theorem prova_simples : (forall A : Prop, A -> A).
    Proof.
        intros A.
        intros prova_de_A.
        exact prova_de_A.
    Qed.
\end{lstlisting}

Onde \emph{prova\_simples} é o nome do teorema, e \emph{Proof/Qed} delimita a
prova. A ferramenta disponibliza uma maneira de visualizar os estados da prova
durante o processo. Assim, quando terminamos o comando \texttt{intros
prova\_de\_A}, temos o seguinte estado:

\begin{lstlisting}[basicstyle=\small]
   A : Prop
   prova_de_A : A
   ============================
   A
\end{lstlisting}

Todos os elementos acima da barra horizontal são nossas \emph{hipóteses}, e
chamamos este conjunto de \emph{contexto}. Abaixo da barra está nosso objetivo
atual. Esta prova foi concluída com a tática \texttt{exact prova\_de\_A}, para
dizer que a prova é exatamente o elemento \texttt{prova\_de\_A}. 

Usando o comando \texttt{Print prova\_simples}, podemos ver o termo de prova
gerado pelas táticas.

\begin{lstlisting}[basicstyle=\small]
prova_simples = 
    fun (A : Prop) (prova_de_A : A) => prova_de_A
         : forall A : Prop, A -> A

\end{lstlisting}

Para um melhor entendimento do funcionamento da ferramenta, da linguagem e
teoria envolvidos, ver \cite{pierce}.
