%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{O cálculo lambda}
No início do século XX, tornou-se necessária, na matemática, uma definição 
precisa para a noção intuitiva do processo computacional. Diversos modelos foram
propostos para resolver este problema. Entre eles está o cálculo lambda,
proposto por Alonzo Church \cite{lambda_first}, em 1936. Inicialmente, o cálculo
fazia parte de um sistema maior, proposto para servir como uma base
formal para o estudo das fundações da matemática. Porém, devido a
inconsistências neste sistema, Alonzo Church foi obrigado a abrir mão de seu
objetivo inicial, separou a parte utilizável do sistema e formou o que hoje
conhecemos como cálculo lambda.

O grande diferencial deste cálculo está em sua expressividade, com poder
computacional equivalente ao da Máquina de Turing, e sua simplicidade,
demonstrada por sua gramática concisa e poucas regras. A ideia central deste
consiste em simular a criação e aplicação de funções. Diferentemente da noção
usual no trabalho matemático, as funções neste sistema são chamadas "anônimas",
pois são definidas tendo em vista somente seus argumentos e o resultado. Como
exemplo, uma função simples como: "$double(x) = 2*x$" \ é definida anonimamente como
"$\lambda x.\ 2*x$". É utilizada também uma notação especial para a aplicação de
funções, denotada como "$ (\lambda x.\ 2*x)$  $3$".

É importante notar que os exemplos acima não são representados exatamente desta
maneira. Como dito anteriormente, o sistema possui uma gramática simples, e
todas as noções, inclusive números e operações, devem ser definidas com base em
abstrações e aplicações. A gramática do cálculo lambda pode ser descrita
sucintamente como:

\[ \tau := x\ |\ \lambda y.\tau\ |\ \tau \tau \]

Onde $\tau$ representa um termo, e \textbf{x} representa uma variável livre. A
variável \textbf{y} no segundo caso é chamada de \textit{variável ligada},
pois suas ocorrências em $\tau$ estão associadas à abstração. O processo
computacional é simulado no sistema através da regra de $\beta$-redução,
definida como:

\[ (\lambda x.t)\ u \rightarrow_{\beta} t\{x/u\} \]

Note que t\{x/u\} é uma \textit{meta-operação}, definida pela substituição das
ocorrências da variável \textbf{x}, no termo \textbf{t}, pelo termo \textbf{u}.
A partir destas definições, várias propriedades sobre o sistema podem ser
estudadas. Entre elas, é importante ressaltar as noções de \textit{forma
 normal} e de \textit{confluência}:

\begin{description}
    \item[Forma normal:] Um termo \textbf{t} é dito estar em forma
    normal quando não existe \textbf{t'} tal que $ t \rightarrow_\beta t' $. 
    É possível demonstrar que nem todo termo que pode ser expressado no sistema
    possui uma forma normal. Como exemplo, observe que $ (\lambda x.x\ x)\ (\lambda
    x.x\ x) \rightarrow_\beta (\lambda x.x\ x)\ (\lambda x.x\ x) $. Um termo é
    dito normalizável quando existe uma estratégia de redução que leva a uma
    forma normal. O termo é \emph{fortemente normalizável} se toda estratégia
    leva à forma normal.

    \item[Confluência:] Um sistema de reescrita, tomando como exemplo o cálculo
    lambda, é dito confluente se, para todo termo \textbf{t}, se $ t
    \rightarrow_\beta t' $ e $ t \rightarrow_\beta t'' $, então deve existir
    um termo \textbf{u} tal que \textbf{t'} e \textbf{t''} reduzem para ele,
    em zero ou mais passos da $\beta$-redução.  Os termos \textbf{t'} e
    \textbf{t''} são ditos \textit{$\beta$-equivalentes}.  A propriedade de
    confluência pode ser entendida, essencialmente, como uma garantia que a
    ordem que as reduções são feitas dentro de um termo não afetam o
    resultado final do processo.

\end{description}

Outro ponto importante a ser mencionado é a noção de $\alpha$-equivalência de
termos. Um termo $(\lambda x. t)$ é dito $\alpha$-equivalente a $(\lambda y. u)$
se $ t\{x/y\} = u $. Esta noção captura a ideia de que a escolha do nome das
variáveis ligadas não importa em geral, sendo o real objeto de interesse a
estrutura do termo. Esta definição é útil para evitar certos problemas, como por
exemplo o de \textit{captura de variáveis livres}. No exemplo:

\[ (\lambda x.\ t)\{y/u\},\ x\ \neq\ y \]

Se a variável \textbf{x} ocorrer livre no termo \textbf{u}, ela será capturada
pela abstração, tornando-se uma variável ligada e mudando a semântica do termo.
Para evitar este problema, podemos renomear a variável ligada \textbf{x}, antes
da substituição, por uma variável nova, de maneira a obter um termo
$\alpha$-equivalente, podendo então realizar a substituição sem modificar a
estrutura do termo.

Como dito anteriormente, o cálculo lambda é usado como modelo teórico para
linguagens funcionais. A noção de $\alpha$-equivalência, apesar de útil, pode ser
muito custosa em uma implementação prática. Por este motivo, foram propostas
algumas representações diferentes de termos, de modo a evitar a necessidade do
renomeamento de variáveis. Entre elas, está a \textit{locally nameless
    representation}, usada para representar os $\lambda$-termos neste trabalho.
A gramática do sistema é modificada parcialmente:

\[ \tau := x\ |\ \lambda . \tau\ |\ \tau \tau \]

Observe que a abstração não carrega mais uma variável ligada. Ao invés disso,
são usados índices (que podem ser números naturais) para representar estas
variáveis. A meta-substituição deve então ser adaptada para levar em conta estes
índices, como no exemplo:

\[ (\lambda.\ 1) \{0/t\} \rightarrow ( \lambda. (1 \{1/t\}) ) \]

Note que, na substituição, o índice a ser substituído foi incrementado ao entrar
na abstração, de modo a corresponder à variável correta a ser substituída. Note
que variáveis livres continuam sendo representadas da mesma maneira. Esta
representação foi proposta por Arthur Charguéraud, junto com provas de
equivalência e um framework para sua utilização em Coq, em \cite{chargueraud}.

Para mais informações a respeito do cálculo lambda, veja \cite{barendregt}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{O sistema $\lambda$ex}

Sabemos que a ordem em que as reduções são feitas não altera a forma normal do
termo, mas isto não significa que não existem vantagens em se adotar certas
estratégias na normalização. Como exemplo, observe os seguintes casos:

\[ ((\lambda.\ x) t) \{1/y\} \rightarrow ((\lambda.\ x\{1/y\})\ t\{1/y\}) 
    \rightarrow ((\lambda.\ x) t') \rightarrow (x\{0/t\}) \rightarrow x
\]

\[ ((\lambda.\ x) t) \{1/y\} \rightarrow (x\{0/t\}) \{1/y\} 
    \rightarrow x \{1/y\} \rightarrow x \]

Veja que, na segunda abordagem, evitamos uma operação potencialmente custosa de
realizar uma substituição em um termo \emph{t} que seria imediatamente
descartado. Infelizmente, o uso da meta-operação nos impede de realizar este
tipo de manipulação, pois a substituição não faz parte da sintaxe do sistema.

Na implementação de linguagens de programação, a substituição muitas vezes é
"atrasado", de modo a evitar computações desnecessárias. Para aproximar o modelo
teórico de seu paralelo prático, podemos tentar fracionar a operação de
substituição em partes atômicas, de maneira a permitir uma manipulação simbólica
mais precisa. Com este objetivo em mente, foi proposto em \cite{delia} o
sistema $\lambda$ex, que utiliza um formalismo conhecido como substituições
explícitas. Este sistema será repetido aqui, e um maior entendimento pode ser
obtido na fonte original. São introduzidas várias mudanças, a começar pela
gramática: 

\[ \tau := x\ |\ \lambda x.\tau\ |\ \tau \tau\ |\ \tau[x/\tau]\ \]

A nova construção é chamada \textit{substituição explícita}, e é o que permite as
manipulações sintáticas com substituições no cálculo. Como consequência desta
mudança, novas regras de redução são adicionadas:

\begin{empheq}[box=\fbox]{align*}
    x[x/u]\ \ \             &\rightarrow_{Var}\ u \\
    t[x/u]\ \ \             &\rightarrow_{Gc}\ t    & if\ \emph{x} \notin fv(t)\\
    (t\ u)[x/v]\ \ \        &\rightarrow_{App}\ t[x/v]\ u[x/v] \\
    (\lambda y.\ u)[x/v]\ \ &\rightarrow_{Lamb}\ (\lambda y.\ u[x/v])\\
    t[x/u][y/v]\ \ \        &\rightarrow_{Comp}\ t[y/v][x/u[y/v]] & if\ y\ \in
    fv(u) \\ 
    (\lambda x.\ t)\ u\ \ \ &\rightarrow_B\ t[x/u]
\end{empheq}

As 5 primeiras regras formam a relação $\rightarrow_x$, e o acréscimo da última
forma a relação $\rightarrow_{Bx}$. 

Observe que, devido ao acréscimo das substituições explícitas, é possível
definir termos que possuem uma sintaxe distinta, diferindo apenas na permutação
de substituições independentes, e que constiturem o mesmo
$\lambda$-termo no sistema original. Assim, é necessário tornar o novo sistema
equacional, adicionando uma relação de equivalência:

\[ t[x/u][y/v] =_C t[y/v][x/u] \ \ \ \ \ if\ y \notin fv(u)\ \&\ x \notin fv(v)\] 

A relação de equivalência $=_e$ é formada com a junção de $=_C$ e
$\alpha$-equivalência. As relações $\rightarrow_{ex}$ e $\rightarrow_{\lambda
    ex}$ são definidas como:

\[t\ \rightarrow_{ex}\ t'\ \iff\ \exists\ s,s'\ t.q.\ t\ =_{e}\ s\
    \rightarrow_x\ s'\ =_e\ t' \]
\[t\ \rightarrow_{\lambda ex}\ t'\ \iff\ \exists\ s,s'\ t.q.\ t\ =_{e}\ s\
    \rightarrow_{Bx}\ s'\ =_e\ t' \]

Estas relações serão amplamente utilizadas ao decorrer deste trabalho. 
O foco principal é a formalização da propriedade \textbf{IE} do sistema, que
pode ser entendida intuitivamente da seguinte maneira: Dados \textbf{t},
\textbf{u} tais que \emph{u} e \emph{t\{x/u\}} são fortemente normalizáveis
no sistema, então o correspondente utilizando substituições explícitas,
\emph{t[x/u]} também será. Ou seja, a normalização da substituição implícita
implica a normalização da explícita.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{O assistente de provas Coq} 
blablabla
