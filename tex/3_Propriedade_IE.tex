Nesta seção, queremos descrever a formalização da propriedade IE.
Esta propriedade é a que garante que, se um termo \emph{t} é fortemente
normalizável no cálculo original, ou seja, toda cadeia de reduções termina,
então ele também é fortemente normalizável no sistema $\lambda ex$.

Para isto, é adicionado mais uma estrutura no sistema, chamada de
\emph{substituição marcada}.

\section{Substituições marcadas}
\label{sec:substitui_es_marcadas}

A ideia é controlar as reduções feitas envolvendo substituições explícitas. Para
isto, adicionamos uma nova substituição na gramática.

\[ \tau := x\ |\ \lambda x.\tau\ |\ \tau \tau\ |\ \tau[x/\tau]\ |\
    \tau[[x/u]]\ \]

Note que na nova substituição, não podemos colocar qualquer qualquer termo no
lugar de \emph{u}. Restringimos o termo \emph{u} a apenas termos da gramática
original, ou seja, sem substituições marcadas. Além disso, é necessário que o
termo seja fortementa normalizável.

Na nossa gramática de pré-termos, este formalismo já está adicionado, sendo
representado pelo construtor \texttt{pterm\_lsub}. Porém, assim como precisamos
de um predicado para verificar se um termo comum está bem formado, vamos criar
um outro predicado, chamado \texttt{lab\_term}. Este predicado terá a mesma
funcionalidade, mas agora extendido para termos com substituições marcadas. 

\begin{lstlisting}[basicstyle=\small]
Inductive lab_term : pterm -> Prop :=
  | lab_term_var : forall x,
      lab_term (pterm_fvar x)
  | lab_term_app : forall t1 t2,
      lab_term t1 -> 
      lab_term t2 -> 
      lab_term (pterm_app t1 t2)
  | lab_term_abs : forall L t1,
      (forall x, x \notin L -> lab_term (t1 ^ x)) ->
      lab_term (pterm_abs t1)
  | lab_term_sub : forall L t1 t2,
     (forall x, x \notin L -> lab_term (t1 ^ x)) ->
      lab_term t2 -> lab_term (t1[t2])
  | lab_term_sub' : forall L t1 t2,
     (forall x, x \notin L -> lab_term (t1 ^ x)) ->
      (term t2) -> (SN lex t2) -> 
      lab_term (t1 [[ t2 ]]).
\end{lstlisting}

Observe que no caso da substituição marcada, temos a exigência \texttt{(SN lex
    t2)}, que indica que \texttt{t2} é fortemente normalizável.

Também devemos extender a noção equivalente de ser localmente fechado, para
manter a equivalência definida no caso do sistema sem as substituições marcadas.

\begin{lstlisting}[basicstyle=\small]
Fixpoint lc_at' (k:nat) (t:pterm) {struct t} : Prop :=
  match t with 
  | pterm_bvar i    => i < k
  | pterm_fvar x    => True
  | pterm_app t1 t2 => lc_at' k t1 /\ lc_at' k t2
  | pterm_abs t1    => lc_at' (S k) t1
  | pterm_sub t1 t2 => (lc_at' (S k) t1) /\ lc_at' k t2
  | pterm_lsub t1 t2 => (lc_at k t2) /\ (SN lex t2) /\ (lc_at' (S k) t1)
  end.
\end{lstlisting}

Observe que no construtor \texttt{ptern\_lsub}, representando a substituição
marcada, foi adicionada também a restrição \texttt{(SN lex t2)}, para que
\texttt{t2} seja fortemente normalizável.

Podemos seguir a prova da equivalência entre \texttt{lab\_term} e
\texttt{lc\_at'} de maneira similar a prova do capítulo anterior, com a ajuda
dos seguintes lemas auxiliares.

\pagebreak

\begin{lstlisting}[basicstyle=\small]

Lemma lc_rec_open_var_rec' : forall x t k,
  lc_at' k (open_rec k x t) -> lc_at' (S k) t.
    
Lemma lc_at_open_var_rec' : forall x t k,
  lc_at' (S k) t -> lc_at' k (open_rec k (pterm_fvar x) t).

Lemma lab_term_to_term'' : forall t,
Lemma term''_to_lab_term : forall t, term'' t -> lab_term t.
Lemma term_impl_lab_term: forall t, term t -> lab_term t.
Lemma lab_term_eq_term'' : forall t, lab_term t <-> term'' t.
\end{lstlisting}

Como no caso do sistema simples, queremos definir classes de equivalências
de termos, para trabalhar módulo permutação de substituições.
Para isso, precisamos definir um novo fecho contextual para os termos com
substituições marcadas.

\begin{lstlisting}[basicstyle=\small]

Inductive lab_contextual_closure (Red : pterm -> pterm -> Prop) 
        : pterm -> pterm -> Prop :=
  | lab_redex : forall t s, Red t s -> lab_contextual_closure Red t s
  | lab_app_left : forall t t' u, lab_term u -> 
        lab_contextual_closure Red t t' -> 
        lab_contextual_closure Red (pterm_app t u) (pterm_app t' u)
  | lab_app_right : forall t u u', lab_term t -> 
        lab_contextual_closure Red u u' -> 
        lab_contextual_closure Red (pterm_app t u) (pterm_app t u')
  | lab_abs_in : forall t t' L, 
    (forall x, x \notin L -> lab_contextual_closure Red (t^x) (t'^x)) 
    -> lab_contextual_closure Red (pterm_abs t) (pterm_abs t')
  | lab_subst_left : forall t t' u L, lab_term u -> 
    (forall x, x \notin L -> lab_contextual_closure Red (t^x) (t'^x)) 
    -> lab_contextual_closure Red  (t[u]) (t'[u])
  | lab_subst_right : forall t u u', lab_body t -> 
     lab_contextual_closure Red u u' -> 
	 lab_contextual_closure Red  (t[u]) (t[u']) 
  | lab_subst'_left : forall t t' u L, term u -> 
    (forall x, x \notin L -> lab_contextual_closure Red (t^x) (t'^x)) 
    -> lab_contextual_closure Red  (t[[u]]) (t'[[u]])
  | lab_subst'_right : forall t u u', lab_body t -> Red u u' -> 
    lab_contextual_closure Red  (t[[u]]) (t[[u']]) 
.
\end{lstlisting}

Em sua maioria, os construtores são análogos aos definidos. Vale notar que ao
invés de se necessitar \texttt{term t} como hipótese, é necessário que o termo
seja marcado, ou seja, que consigamos demonstrar \texttt{lab\_term t}.
Adicionamos também construtores pras substituições marcadas. 
Para uma redução fora da substituição marcada, o processo é análogo ao da comum.
Para dentro desta, não podemos construir um fecho a partir de outro: é
necessário que o termo \texttt{u} se reduza para \texttt{u'} diretamente.

Podemos então definir a relação equacional para termos marcados.

\begin{lstlisting}[basicstyle=\small]
    
Inductive lab_eqc  : pterm -> pterm -> Prop := 
| lab_eqc_rx1 : forall t u v, 
                  lab_term u -> term v -> 
                  lab_eqc (t[u][[v]]) ((& t)[[v]][u]) 
| lab_eqc_rx2 : forall t u v, 
                  term u -> lab_term v -> 
                  lab_eqc (t[[u]][v]) ((& t)[v][[u]]) 
| lab_eqc_rx3 : forall t u v, 
                  term u -> term v -> 
                  lab_eqc (t[[u]][[v]]) ((& t)[[v]][[u]]).
\end{lstlisting}

Os construtores basicamente definem como permutar duas substituições, desde que
uma delas seja marcada. Como requisito, é necessário garantir a propriedade
\texttt{lab\_term} ou \texttt{term}, dependendo da substituição. 

Para uso futuro, definimos um lema de simetria da relação. Sua prova é feita por
análise de casos simples, apenas usando o lema \texttt{bswap\_idemp} para
reduzir permutações de índices que não alteram a semântica do termo.

\begin{lstlisting}[basicstyle=\small]
Lemma lab_eqc_sym : forall t u, lab_eqc t u -> lab_eqc u t.
\end{lstlisting}

A equação principal utilizada nos termos marcados será a relação 
\texttt{=\textasciitilde e}, definida como o fecho contextual e transitivo do
predicado \texttt{lab\_eqc}.

\pagebreak

\begin{lstlisting}[basicstyle=\small]
Definition lab_eqC (t: pterm) (u : pterm) :=  
    trans_closure (lab_contextual_closure lab_eqc) t u . 
Notation "t =~e u" := (lab_eqC t u) (at level 66).
\end{lstlisting}
