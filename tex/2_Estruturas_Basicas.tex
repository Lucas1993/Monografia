\section{Termos}
\subsection{A Gramática de pré-termos}
\label{sec:termos}

Nesta seção, será feita um paralelo entre as estruturas básicas do sistema
$\lambda ex$ e sua formalização em Coq.

Como visto em \ref{sub:int_lex}, o sistema possui uma gramática que pode ser vista como
uma extensão do cálculo lambda original, consistindo de variáveis, abstrações,
aplicações e \emph{substituições explícitas}. Ela pode ser descrita sucintamente
como abaixo.

\[ \tau := x\ |\ \lambda x.\tau\ |\ \tau \tau\ |\ \tau[x/\tau]\ \]

Já encontramos então nossa primeira divergência na formalização. Neste projeto,
será usada a representação chamada \textit{Locally Nameless Representation}
(LNR), onde as variáveis ligadas são representadas por índices. Por conta disso,
existem termos nesta nova gramática que não possuem correspondentes no sistema
original, por conta de índices que não estão ligados a nenhuma abstração.

Assim, torna-se necessária uma gramática de \emph{pré-termos}, que consiste de
todos os termos possíveis de serem escritos em LNR. Esta gramática é formalizada
usando um tipo indutivo.
\pagebreak

\begin{lstlisting}[basicstyle=\small]
Inductive pterm : Set :=
  | pterm_bvar : nat -> pterm
  | pterm_fvar : var -> pterm
  | pterm_app  : pterm -> pterm -> pterm
  | pterm_abs  : pterm -> pterm
  | pterm_sub  : pterm -> pterm -> pterm 
  | pterm_lsub : pterm -> pterm -> pterm.
\end{lstlisting}

Veja que variáveis livres e ligadas possuem construtores distintos. Para as
livres, o construtor correto é \texttt{pterm\_bvar}, que recebe um natural
representando um índice. As variáveis livres são construídas com
\texttt{pterm\_fvar}, recebendo um elemento do tipo \texttt{var}, definido no
framework de Charguéraud.
As aplicações, abstrações e substituições são representadas através do
construtores \texttt{pterm\_app}, \texttt{pterm\_abs} e \texttt{pterm\_sub},
respectivamente. Todos recebem um ou dois pré-termos, que correspondem aos
termos internos das estruturas.

O último construtor, \texttt{pterm\_lsub}, será usado para representar
\emph{substituições marcadas}, um formalismo necessário para as provas de
correspondência com a meta-substituição.

\subsection{Termos bem formados}

Devido à correspondência assimétrica entre os termos do sistema $\lambda ex$ e
em LNR, torna-se necessário definir os predicados de boa formação de termos.

Como pré-requisito para a definição destes predicados, precisamos implementar as
noções de abertura e fechamento de termos, como visto em \ref{sub:int_lnr}. 
Relembrando, a operação de abertura foi definida como $t^{x} \equiv t\{0/x\}$.

Para implementar tal operação, precisaremos de duas funções, \texttt{open\_rec}
e \texttt{open}.

\begin{lstlisting}[basicstyle=\small]
Fixpoint open_rec (k : nat) (u : pterm) (t : pterm) {struct t} 
        : pterm := ...

Definition open t u := open_rec 0 u t.
\end{lstlisting}

A primeira adentra o termo \texttt{t} recursivamente, procurando pelo índice
\texttt{k} e substituindo pelo termo \texttt{u}. Ao encontrar uma abstração ou
substituição, o índice \texttt{k} é incrementado.  A segunda, que é a chamada da
operação de fato, apenas chama \texttt{open\_rec} com $k = 0$.

Similarmente, a operação de fechamento foi definida como $ ^{\textbackslash x}t
\equiv \{0 \leftarrow t\}$. Esta operação é definida através da função
\texttt{close}.

\begin{lstlisting}[basicstyle=\small]
Fixpoint close_rec  (k : nat) (x : var) (t : pterm) {struct t} 
    : pterm := ...

Definition close t x := close_rec 0 x t.
\end{lstlisting}

Podemos agora definir o predicado \texttt{term}, representando termos bem
formados, com base nas seguintes regras de inferência.

\begin{mathpar} 
    \inferrule*[Right=term\_var]{  }
    {lc(x)}
    \and
    \inferrule*[Right=term\_app]{lc\ t1 \\ lc\ t2}
    {lc(t1\ t2)}
    \and
    \inferrule*[Right=term\_abs]{\forall x \notin L,\ lc\ (t^{x})}
    {lc(\lambda. t)}
    \\
    \inferrule*[Right=term\_sub]{\forall x \notin L,\ lc\ (t^{x}) \\ lc\ u}
    {lc(t[u])}
\end{mathpar}

O predicado \texttt{term} recebe um pré-termo, e indica que este elemento é bem
formado, ou seja, não possui índices livres. Para cada tipo de pré-termo, temos
um construtor diferente do predicado. Observe que não existe regra de inferência
para índices livres, como desejado.

Em alguns casos, como dito na subseção \ref{sub:int_lnr}, pode ser mais
vantajoso verificar se um termo está bem formado com uma função recursiva.
Tal verificação é feita através do predicado \texttt{term'}, que deve funcionar de
maneira equivalente ao predicado \texttt{term}. Este novo predicado é definido
com base na definição recursiva \texttt{lc\_at}. A função \texttt{lc\_at}
verifica se o termo \emph{t} está \textit{fechado} a um nível \emph{k}, ou seja,
se não existe índice livre de valor maior ou igual a \emph{k}. Sua implementação
é feita com base na definição da tabela \ref{table:lc_at}.

\begin{lstlisting}[basicstyle=\small]
Fixpoint lc_at (k:nat) (t:pterm) {struct t} : Prop := ...

Definition term' t := lc_at 0 t.
\end{lstlisting}

Assim, essa equivalência também teve que ser formalizada, utilizando uma série
de lemas auxiliares. 

Primeiramente, foram provados dois resultados de enfraquecimento para o
\texttt{lc\_at}.

\begin{gather}
 lc\_rec\_open\_var\_rec:\ \forall\ x\ t\ k,\ (lc\_at\ k\ (open\_rec\ k\ x\
    t))\ \rightarrow\ (lc\_at\ (S\ k)\ t) \nonumber \\
 lc\_at\_open\_var\_rec:\ \forall\ x\ t\ k,\ (lc\_at\ (S\ k)\ t)\ \rightarrow\
    (lc\_at\ k\ (open\_rec\ k\ x\ t)) \nonumber 
\end{gather}


O primeiro lema garante que, se um termo \emph{t}, aberto com uma variável a um
nível \emph{k}, é fechado a este mesmo nível \emph{k}, então o termo \emph{t}
sem a abertura é fechado a nível \emph{k + 1}.

O segundo é exatamente o contrário: Se um termo \emph{t} é fechado a um nível
\emph{k + 1}, então este mesmo termo, aberto com uma variável a nível \emph{k},
é fechado a nível \emph{k}.

Já podemos agora provar a equivalência entre as duas definições de termos bem
formados.

\begin{gather}
 term\_eq\_term':\ \forall\ t,\ (term\ t)\ \iff\ (term'\ t) \nonumber 
\end{gather}

\begin{itemize}
    \item[($\Rightarrow$)] Este caso é bem direto, fazendo uma indução no
        predicado \texttt{term t}. As hipóteses de indução resolvem os casos
        diretamente, exceto para abstração e substituição. Nesses, a hipótese é
        dada para $t^x$, quando precisamos provar $lc\_at\ 1\ t$. Felizmente os
        lemas de enfraquecimento acima resolvem, bastando usar o lema
        lc\_rec\_open\_var\_rec.
    \item[($\Leftarrow$)] O segundo caso não é tão imediato, pois fazemos uma
        indução no \emph{tamanho do termo}, para auxiliar na prova. A hipótese
        de indução se refere a termos com tamanho igual ao do termo sobre qual
        queremos provar a propriedade. Isto é útil pois o tamanho de um termo ao
        ser aberto não muda. Novamente, no caso da abstração e substituição,
        precisamos fazer um ajuste utilizando o lema lc\_at\_open\_var\_rec.
\end{itemize}

\section{Relações}
\label{sec:rela_es}

\subsection{Equivalência de termos}
\label{sub:equival_ncia_de_termos}

Como dito anteriormente, o acréscimo de substituições explícitas pode nos levar
a casos em que um mesmo termo no cálculo original tenha duas representações no
sistema. Observe o exemplo abaixo:

\[ t\{x/u\}\{y/v\},\ \ x \notin fv(v),\ y \notin fv(u) \]
\[ t[x/u][y/v]\ \ \ t[y/v][x/u]\]

Como as substituições são independentes, ambas as representações são válidas.
Para resolver este problema, foi adicionado no sistema uma regra de
\emph{permutação de substituições independentes}.

\[ t[x/u][y/v] =_C t[y/v][x/u] \ \ \ \ \ se\ y \notin fv(u)\ \&\ x \notin fv(v)\] 

Dizemos que ambas as representações são \emph{equivalentes}.

Precisamos, então, formalizar essa definição no sistema.

\begin{lstlisting}[basicstyle=\small]
Inductive eqc : pterm -> pterm -> Prop := 
  | eqc_def: forall t u v, term u -> term v -> 
          eqc (t[u][v]) ((& t)[v][u]).
\end{lstlisting}

As exigências que \emph{u} e \emph{v} sejam termos são puramente técnicas, pois
queremos trabalhar apenas com termos sem índices livres no sistema. O único
outro detalhe que muda na formalização é ocorrência do operador $\&$, que
troca todas as ocorrências de índices zero e um, para que eles continuem se
referindo à mesma substituição.

Note que esta definição ainda possui muitas limitações. Por exemplo, se um termo
possui uma lista de substituições, só podemos trocar as duas últimas. Também não
é possível realizar permutações em subtermos, ou várias permutações seguidas.
Assim, precisamos criar \emph{fechos} em cima dessa definição, para ajustar às
nossas necessidades. Nas regras a seguir, \emph{R} indica uma relação entre dois
termos. 

\begin{mathpar} 
    \inferrule*[Right=ES\_redex]{ (R\ t\ s) }
    {(ES\_contextual\_closure\ R)\ t\ s}
    \\
    \inferrule*[Right=ES\_app\_left]{((ES\_contextual\_closure\ R)\ t\ t'),\
        (term\ u)}
    {((ES\_contextual\_closure\ R)\ (t\ u)\ (t'\ u))}
    \\
    \inferrule*[Right=ES\_app\_right]{((ES\_contextual\_closure\ R)\ t\ t'),\
        (term\ u)}
    {((ES\_contextual\_closure\ R)\ (u\ t)\ (u\ t'))}
    \\
    \inferrule*[Right=ES\_abs\_in]{(\forall\ x,\ x \notin L \rightarrow
        ((ES\_contextual\_closure\ R)\ t^x\ t'^x))}
    {((ES\_contextual\_closure\ R)\ (\lambda . t)\ (\lambda . t'))}
    \\
    \inferrule*[Right=ES\_subst\_left]{(\forall\ x,\ x \notin L \rightarrow
        ((ES\_contextual\_closure\ R)\ t^x\ t'^x)),\ (term\ u)}
    {((ES\_contextual\_closure\ R)\ (t[u])\ (t'[u]))}
    \\
    \inferrule*[Right=ES\_subst\_right]{((ES\_contextual\_closure\ R)\ u\ u'),\
        (term\ t)}
    {((ES\_contextual\_closure\ R)\ (t[u])\ (t[u']))}
\end{mathpar}


\begin{lstlisting}[basicstyle=\small]
Definition eqc_ctx (t u: pterm) := ES_contextual_closure eqc t u.
Notation "t =c u" := (eqc_ctx t u) (at level 66). 
\end{lstlisting}

A definição \texttt{ES\_contextual\_closure} é um dos chamados \emph{fechos
    contextuais}. A ideia é que, se vale $t \rightarrow_R t'$, então, para
qualquer termo construído a partir de \emph{t}, vale a redução pelo fecho contextual de
R, para o mesmo termo, mas construído a partir de \emph{t'}. Como exemplo:

\[(t \rightarrow_R t') \Rightarrow ((pterm\_app\ t\ u)
    \rightarrow_{ES\_Contextual\_Closure\ R} (pterm\_app\ t'\ u)) \]

Definimos também os fechos \emph{transitivo} e \emph{transitivo-reflexivo}.
Essencialmente, se temos $t \rightarrow_R t'$ e $t' \rightarrow_R t''$, então
vale o fecho transitivo $t \rightarrow_{R^+} t''$. Isto é representado pelo
construtor \texttt{transitive\_reduction}. Note que isto vale para
apenas um passo também: $t \rightarrow_R t'$ implica $t \rightarrow_{R^+} t'$.
Este é representado pelo construtor \texttt{one\_step\_reduction}.

\begin{table}
\begin{mathpar} 
    \inferrule*[Right=one\_step\_reduction]{ (R\ t\ s) }
    {(trans\_closure\ R)\ t\ s}
    \\
    \inferrule*[Right=transitive\_reduction]{((trans\_closure\ R)\ t\ u),\
        ((trans\_closure\ R)\ u\ t')}
    {((trans\_closure\ R)\ (t\ t'))}
\end{mathpar}
    \caption{Fecho transitivo}
\end{table}

O fecho \emph{transitivo-reflexivo} é uma extensão do transitivo, onde vale $t
\rightarrow_{R^*} t$, sempre. A extensão é presentada por dois construtores:
\texttt{reflexive\_reduction}, que garante \texttt{star\_closure R t t}, e
\texttt{star\_trans\_reduction}, que constrói \texttt{star\_closure R t u}, se
vale \texttt{trans\_closure R t u}.

\begin{table}
\begin{mathpar} 
    \inferrule*[Right=reflexive\_reduction]{  }
    {(star\_closure\ R)\ t\ t}
    \\
    \inferrule*[Right=star\_trans\_reduction]{((trans\_closure\ R)\ t\ u)}
    {((star_trans\_closure\ R)\ (t\ u))}
\end{mathpar}
    \caption{Fecho transitivo-reflexivo}
\end{table}

\begin{lstlisting}[basicstyle=\small]
Definition eqc_trans (t u: pterm) := (trans_closure eqc_ctx) t u.
Notation "t =c+ u" := (eqc_trans t u) (at level 66). 

Definition eqC (t : pterm) (u : pterm) := (star_closure eqc_ctx) t u.
Notation "t =e u" := (eqC t u) (at level 66). 
\end{lstlisting}


Assim, a relação de equivalência que é interessante ser estudada é a $=_e$, que
permite vários passos de permutações, além de permutações no interior dos
termos. Uma importante diferença de provas usando equivalências no papel e numa
formalização é que resultados que são intuitivos e admitidos num ambiente
informal devem ser provados minuciosamente.

Como exemplo, podemos querer mostrar a compatibilidade da igualdade com a
função \texttt{lc\_at}. Isto é intuitivo, pois permutar duas substituições não
irá criar índices livres. Porém, é preciso entrar em detalhes na prova formal. 

\begin{lstlisting}[basicstyle=\small]
Lemma lc_at_eqc : forall n t u, eqc t u  -> (lc_at n t <-> lc_at n u).
Lemma lc_at_ES_ctx_eqc: forall n t u, (ES_contextual_closure eqc) t u  
                            -> (lc_at n t <-> lc_at n u).
Lemma lc_at_eqC : forall n t t', t =e t' -> 
                            (lc_at n t <-> lc_at n t').
\end{lstlisting}

Observe que precisamos provar três resultados. Não basta mostrar que o predicado
\texttt{eqc} é compatível com \texttt{lc\_at}, pois ainda usaremos seus fechos.
A prova de \texttt{lc\_at\_eqc} já apresenta certos detalhes. Ela é feita
através de uma análise de casos do predicado \texttt{eqc}. É preciso realizar
certos ajustes com índices e usar a equivalência entre \texttt{lc\_at} e o
predicado \texttt{term}, além de regras de enfraquecimento para o \texttt{lc\_at}.

Os casos dos fechos em geral saem mais rapidamente, fazendo indução no próprio
fecho. No caso do fecho contextual, os casos de abstração e substituição se
tornam um pouco mais longos, mas são facilmente resolvidos usando a propriedade
\texttt{lc\_at\_open'}, que garante que se um termo está fechado a um nível
\emph{n}, abrí-lo a um nível $k < n$ não gera índices livres.

Esta é uma parte do trabalho especialmente extensa e detalhada. É preciso
mostrar que vários predicados importantes da teoria são preservados pelas
classes de equivâlencia entre termos. Várias vezes durante as provas
trabalharemos com termos equivalentes módulo $=_e$ e, sem uma base bem
construída de resultados sobre a relação de \texttt{eqC}, fica impossível
concluir diversas provas.

Os principais resultados a serem provados nesta parte incluem:

\begin{itemize}
    \item Preservação da estrutura de termos pela equivalência. Construtores de
        termos, abertura de termos, substituições e renomeamento de variáveis
        devem funcionar de maneira análoga para dois termos equivalentes.
    \item Boa formação de termos e corpos de abstrações, conjunto de variáveis
        livres e reduções dentro de fechos contextuais também devem ser
        preservadas pela equivalência.
\end{itemize}

\subsection{Reduções do Sistema}
\label{sub:redu_es_do_sistema}

Com a estrutura de termos e as regras de equivalência bem estabelecidas, podemos
iniciar a formalização das reduções do sistema $\lambda ex$.
As regras de redução listadas em  \ref{table:red_lambex} serão formalizadas nos
tipos indutivos \texttt{sys\_x} e \texttt{rule\_b}.

\begin{lstlisting}[basicstyle=\small]
Inductive rule_b : pterm -> pterm -> Prop := ...
Notation "t ->_B u" := (rule_b t u) (at level 66).

Inductive sys_x : pterm -> pterm -> Prop := ...
Notation "t ->_x u" := (sys_x t u) (at level 59, left associativity).
\end{lstlisting}

A relação $\rightarrow_x$ é definida como sendo exatamente o predicado
\texttt{sys\_x}. Algumas exigências técnicas de \emph{term} e \emph{body} são
adicionadas para auxiliar nas provas, já que queremos sempre trabalhar com
termos bem formados.

O predicado \texttt{rule\_b} é o que formaliza a regra $\rightarrow_B$, sendo
esta a regra que reduz uma aplicação a uma substituição explícita. Podemos, a
partir destes dois predicados, definir a regra de redução principal do sistema
$\lambda ex$.

\begin{lstlisting}[basicstyle=\small]
Inductive sys_Bx: pterm -> pterm -> Prop :=
| B_lx : forall t u, t ->_B u -> sys_Bx t u
| sys_x_lx : forall t u, t ->_x u -> sys_Bx t u.

Notation "t ->_Bx u" := (sys_Bx t u).

red_ctx_mod_eqC = 
fun (R : pterm -> pterm -> Prop) (t u : pterm) =>
exist t' u', t =e t' /\ ES_contextual_closure R t' u' /\ u' =e u
     : (pterm -> pterm -> Prop) -> pterm -> pterm -> Prop

Definition lex t u :=  red_ctx_mod_eqC sys_Bx t u.
Notation "t -->lex u" := (lex t u) (at level 66).

Definition lex_trs t u := trans_closure lex t u.
Notation "t -->lex+ u" := (lex_trs t u) (at level 66).

Definition lex_str t u := star_closure lex t u.
Notation "t -->lex* u" := (lex_str t u) (at level 66).
\end{lstlisting}

O análogo da regra $\rightarrow_{\lambda ex}$ no sistema será a relação
\texttt{''-->lex*"}, construída a partir do fecho transitivo-reflexivo,
contextual e equacional da relação $\rightarrow_{Bx}$.

\vfill
Para auxiliar nas provas, definimos alguns predicados que garantem que estamos
trabalhando sempre com termos, e que representam algumas noções intuitivas das
reduções.

\begin{table}[h]
\begin{mathpar} 
    \inferrule*{(red\_regular\ R),\ (R\ t\ u)}
    {term\ t\ \and term\ u}
\end{mathpar}
    \caption{Noção de regularidade}
\end{table}


A propriedade de regularidade é interessante para facilitar em diversas provas,
já que desejamos evitar trabalhar com termos que possuem índices livres.
Basicamente, se fizemos a redução \emph{R} entre dois pré-termos,
ambos são termos bem formados.


\begin{table}[h]
\begin{mathpar} 
    \inferrule*{(red\_out\ R),\ (R\ t\ u)}
    {R\ ([x \rightarrow u]t)\ ([x \rightarrow u]t')}
\end{mathpar}
    \caption{Redução fora da meta-substituição}
\end{table}


A propriedade \texttt{red\_out} garante que a redução pode ser feita em um
termo afetado por uma meta-substituição, sendo $[x\ \mapsto\ u]$ a substituição que
troca todas as ocorrências de \texttt{x} pelo termo \texttt{u}. Ela é útil pois
esta meta-substituição pode ser vista como uma generalização da abertura de um
termo.

\begin{table}[h]
\begin{mathpar} 
    \inferrule*{(red\_rename\ R),\ (\forall x,\ x \notin fv(t) \rightarrow R\
        (t^x) \ (u^x))}
    {R\ (t^y)\ (u^y)}
\end{mathpar}
    \caption{Redução fora da meta-substituição}
\end{table}

A propriedade \emph{red\_out} pode ser comparada à $\alpha$-equivalência de termos no cálculo
original. Basicamente, se um termo \texttt{t} aberto com uma variável $x \notin
fv(t)$ se reduz a um \texttt{t'}, também aberto com \texttt{x}, então este
\texttt{x} pode ser trocado por outra variável $y \notin fv(t)$, preservando a
redução $\rightarrow_{lex}$.

Estes resultados auxiliam muito em diversas provas. Em especial, os resultados
envolvendo abertura de termos e índices livres são necessários para provas em
que fazemos indução na estrutura do termo, pois, em geral, no caso da abstração
as hipóteses se referem ao sub-termo aberto com uma variável.

