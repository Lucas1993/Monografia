\chapter{Introdução}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Assistentes de Prova} 
\subsection{Motivação}

Assistentes de provas são sistemas computacionais que permitem aos usuários
especificar teorias e provar propriedades destas em um computador. Neles, o
usuário pode construir toda sua teoria matemática em uma linguagem em que o
sistema seja capaz de verificar sua correção. Ou seja, a principal motivação por
trás de um assistente de prova é verificar formalmente as propriedades de uma
teoria. Apesar de já existir um processo humano de verificação, muitas vezes
ocorrem erros neste processo, e provas que foram aceitas numa primeira avaliação
são descobertas problemáticas algum tempo depois. Como exemplo, podemos citar o
teorema das quatro cores \cite{four_colour}, que desafiou matemáticos por anos e
foram apresentadas falsas provas diversas vezes. Este teorema foi provado em
2008, no assistente de prova  Coq, estabelecendo, assim, a sua correção.
\cite{4colproof, gonthieril:_four_colour_theor}

Mas, então, o que exatamente significa uma prova? Uma prova normalmente é
definida como o processo de se estabelecer a validade de alguma afirmação. Na
matemática, as provas costumam exigir uma clareza e rigor mais extremo, de modo
a se tornar indiscutível quando analizada com cuidado. Porém, matemáticos são
humanos e, infelizmente, cometem erros. Com isto em mente, foi definida uma
noção ainda mais forte de prova, chamada \emph{prova formal}.

Uma prova formal é uma árvore finita cujos nós são marcados com fórmulas
lógicas. As folhas desta árvore são marcadas com axiomas, enquanto que os nós
filhos são marcados com fórmulas obtidas a partir dos nós pais via regras de
inferência. A vantagem do rigor das provas formais é que conferí-la se torna um
processo muito mais simples, sendo necessário apenas confirmar de onde vem cada
uma das sentenças.

Por este motivo, provas formais são comumente construídas e verificadas pelos
assistentes de prova. Ao utilizar a linguagem do assistente, ele aos poucos
constrói a sequência de sentenças e simultaneamente checa sua validade. Porém,
isto gera outra dúvida: Por que confiar nos assistentes de prova?


\begin{description}
    \item[Lógica do assistente:] Os assistentes de prova em geral possuem uma
        teoria forte no qual são baseados. Em geral, existe um sistema
        matemático independente de implementação que pode ser estudado e
        verificado anteriormente.
    \item[Checagem do assitente:] O assistente em si é, também, um programa. Assim,
        podemos analizar seus algoritmos, demonstrar que só é possível provar
        teoremas derivados no sistema lógico interno e testar seu funcionamento
        como um programa normal.
    \item[Critério de De Bruijn:] O critério de de Bruijn afirma que a correção
        de um sistema deve ser garantida por um verificador \emph{pequeno}
        \cite{freek}. Em outras palavras, deve haver um \emph{kernel} pelo qual
        todas as fórmulas passam. Assim, se torna mais fácil estabelecer a
        confiabilidade do sistema, pois podemos verificar o kernel
        separadamente. Nem todos os assistentes de prova passam neste critério,
        como visto na Tabela \ref{table:dbj_crit}.
\end{description}

\begin{table}[h]
\centering
\caption{Relação entre assistentes de prova e o critério de de Bruijn \cite{freek}}
\label{table:dbj_crit}
\begin{tabular}{l|c}
              & \multicolumn{1}{l}{Critério de de Bruijn} \\ \hline
HOL           & $\bullet$                                 \\
Mizar         & \multicolumn{1}{l}{}                      \\
PVS           & \multicolumn{1}{l}{}                      \\ 
Coq           & $\bullet$                                 \\
Otter/Ivy     & $\bullet$                                 \\
Isabelle/Isar & $\bullet$                                 \\
Alfa/Agda     & $\bullet$                                 \\
ACL2          &                                           \\
PhoX          & $\bullet$                                 \\
IMPS          &                                           \\
Metamath      & $\bullet$                                 \\
Theorema      &                                           \\
Lego          & $\bullet$                                 \\
NuPRL         &                                           \\
$\Omega$mega  & $\bullet$                                        
\end{tabular}
\end{table}


Existe um grande número de matemáticos interessados em assistentes de prova,
buscando construir uma teoria consistente para o uso destes e produzindo o
software necessário para facilitar seu uso. Em especial, um dos assistentes com
maior uso é o chamado Coq, a ser apresentado a seguir.

Para uma visão geral sobre o histórico e uso de assistentes de prova, veja
\cite{proof_assist}. 

\subsection{O assistente de prova Coq}

Neste trabalho, usaremos o Coq, um assistente de provas que é desenvolvido desde
1983, pelo INRIA (Institut-National de Recherche en Informatique et en
Automatique). O Coq provê um rico ambiente para o desenvolvimento de um
raciocínio formal checado automaticamente. O núcleo do sistema é um checador de
provas simples que garante que apenas passos válidos de dedução são efetuados.
Além deste núcleo, o ambiente provê diversas táticas para facilitar a
construções de provas, junto com uma vasta biblioteca de definições e teoremas
comuns.

A ferramenta vem acompanhada de uma linguagem de programação funcional, com
tipos dependentes. É através desta linguagem que podemos criar as definições e
construir as provas das propriedades de nossa teoria. Ela é baseada no Cálculo
de Construções Indutivas \cite{coquand}, uma extensão do cálculo $\lambda$ que
serve como modelo teórico para o sistema. O processo de se verificar a correção
de uma prova em Coq se reduz ao problema de \emph{checagem de tipos}. A seguir,
será feita uma introdução à sintaxe e ao funcionamento da ferramenta, baseada em
tutoriais disponibilizados na página oficial do sistema, em \cite{coq} e
\cite{coq2}.


Os objetos de Coq podem ser divididos em duas categorias, \emph{Prop} e
\emph{Type}. A categoria \emph{Prop} é a das proposições bem formadas. Um
exemplo de proposição na linguagem seria:

\bigskip
\coqdockw{\ensuremath{\forall}} \coqdocvar{A} \coqdocvar{B} : \coqdockw{Prop},
\coqdocvar{A} \ensuremath{\rightarrow} (\coqdocvar{A} \ensuremath{\lor}
\coqdocvar{B}).\coqdoceol
\bigskip

Predicados podem ser definidos indutivamente. Na definição a seguir,
\texttt{even} é um predicado que indica que um natural é par, e \texttt{odd}
indica que um natural é ímpar.

\bigskip \coqdockw{Inductive} \coqdocvar{even} : \coqdocvar{nat}
\ensuremath{\rightarrow} \coqdockw{Prop} :=\coqdoceol 
\coqdocindent{2.00em}\ensuremath{|} \coqdocvar{even\_0} : \coqdocvar{even} 0\coqdoceol
\coqdocindent{2.00em}\ensuremath{|} \coqdocvar{even\_S} \coqdocvar{n} :
\coqdocvar{odd} \coqdocvar{n} \ensuremath{\rightarrow} \coqdocvar{even}
(\coqdocvar{n} + 1)\coqdoceol \coqdockw{with} \coqdocvar{odd} :
\coqdocvar{nat} \ensuremath{\rightarrow} \coqdockw{Prop} :=\coqdoceol
\coqdocindent{2.00em}\ensuremath{|} \coqdocvar{odd\_S} \coqdocvar{n} :
\coqdocvar{even} \coqdocvar{n} \ensuremath{\rightarrow} \coqdocvar{odd}
(\coqdocvar{n} + 1).\coqdoceol \bigskip

Predicados também podem ser feitos como definições diretas, como:

\bigskip
\coqdockw{Definition} \coqdocvar{sqr} (\coqdocvar{x} : \coqdocvar{N}) :=
\coqdoctac{\ensuremath{\exists}} \coqdocvar{z}, \coqdocvar{z}
\ensuremath{\times} \coqdocvar{z} = \coqdocvar{x}.\coqdoceol
\bigskip

Assim, podemos utilizar estes predicados como propriedades de algum objeto,
provando algo como \emph{even(2)} ou \emph{sqr(4)}.

\emph{Type} é a categoria de estruturas matemáticas e estruturas de dados.
Alguns exemplos de tipos são:

\bigskip
\coqdocvar{$\mathbb{Z}$} \ensuremath{\times} \coqdocvar{$\mathbb{Z}$}
\ensuremath{\rightarrow} \coqdocvar{$\mathbb{Z}$}
\bigskip

Este é um tipo funcional.  \coqdocvar{$\mathbb{Z}$} \ensuremath{\times}
\coqdocvar{$\mathbb{Z}$} é o tipo de pares de números inteiros. O tipo completo,
\coqdocvar{$\mathbb{Z}$} \ensuremath{\times} \coqdocvar{$\mathbb{Z}$}
\ensuremath{\rightarrow} \coqdocvar{$\mathbb{Z}$}, consiste de funções de pares
de inteiros que retornam inteiros.

Tipos também podem ser definidos indutivamente:

\bigskip
\coqdockw{Inductive} \coqdocvar{nat} : \coqdockw{Set} :=\coqdoceol
\coqdocindent{2.00em} \ensuremath{|} 0 : \coqdocvar{nat}\coqdoceol 
\coqdocindent{2.00em} \ensuremath{|} \coqdocvar{S} : \coqdocvar{nat} \ensuremath{\rightarrow}
\coqdocvar{nat}.\coqdoceol
\bigskip

Neste caso, elementos do tipo \emph{nat} são: 0, S ( 0 ), S ( S ( 0 ) ), etc.

O desenvolvimento de provas em Coq é feito através de uma linguagem de provas,
que permite um processo guiado pelo usuário. Ao utilizar uma tática, o usuário
está construindo os objetos de prova. Por exemplo, a tática
\texttt{intro n}, onde \texttt{n} é do tipo \texttt{nat}, constrói o termo (com um
buraco):

\bigskip
\coqdockw{fun} (\coqdocvar{n}:\coqdocvar{nat}) \ensuremath{\Rightarrow} \coqdocvar{\_}\coqdoceol
\bigskip

Onde \_\ representa um termo que irá ser construído futuramente, utilizando
outras táticas. 

Neste trabalho, precisaremos também definir algumas funções recursivas. Para
garantir a consistência do sistema, a ferramenta exige que todas as funções
sejam terminantes. Um exemplo da sintaxe usada para definir funções no trabalho
pode ser visto abaixo.

\bigskip
\coqdocnoindent \coqdockw{Fixpoint} \coqdocvar{mult\_5} (\coqdocvar{n} :
\coqdocvar{nat}) : \coqdocvar{nat} :=\coqdoceol \coqdocindent{2.00em}
\coqdockw{match} \coqdocvar{n} \coqdockw{with}\coqdoceol \coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{S} \coqdocvar{k} \ensuremath{\Rightarrow} 5 +
(\coqdocvar{mult\_5} \coqdocvar{k})\coqdoceol \coqdocindent{2.00em}
\ensuremath{|} 0   \ensuremath{\Rightarrow} 0\coqdoceol \coqdocindent{2.00em}
\coqdockw{end}.\coqdoceol \coqdocemptyline
\bigskip

A função é chamada \texttt{mult\_5} e recebe um natural. Ela realiza uma
análise de casos no argumento, observando seus construtores. Caso o número seja
zero, a função retorna zero. Se for o sucessor de algum natural \texttt{k}, ela
soma 5 ao resultado de \texttt{mult\_5 k}. O sistema consegue deduzir a
terminação desta função, pois a chamada recursiva é realizada em um subtermo do
argumento inicial.

Como exemplo de uma prova simples a ser realizada no sistema, podemos comparar
o funcionamento da nossa função com a multiplicação padrão do Coq.

\bigskip
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{mult\_5\_is\_correct}:
\coqdockw{\ensuremath{\forall}} \coqdocvar{n} : \coqdocvar{nat},
(\coqdocvar{mult\_5} \coqdocvar{n}) = 5*\coqdocvar{n}.\coqdoceol \coqdocnoindent
\coqdockw{Proof}.\coqdoceol \coqdocindent{2.00em} \coqdoctac{intros}.\coqdoceol
\coqdocindent{2.00em} \coqdoctac{induction} \coqdocvar{n}.\coqdoceol
\coqdocindent{2.00em} \coqdoctac{simpl}. \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{2.00em} \coqdoctac{simpl} \coqdocvar{mult\_5}.\coqdoceol
\coqdocindent{2.00em} \coqdoctac{rewrite} \coqdocvar{mult\_comm}.\coqdoceol
\coqdocindent{2.00em} \coqdoctac{simpl}.\coqdoceol \coqdocindent{2.00em}
\coqdoctac{rewrite} \coqdocvar{IHn}.\coqdoceol \coqdocindent{2.00em}
\coqdoctac{rewrite} \coqdocvar{mult\_comm}.\coqdoceol \coqdocindent{2.00em}
\coqdoctac{reflexivity}.\coqdoceol \coqdocnoindent \coqdockw{Qed}.\coqdoceol
\bigskip

No exemplo acima, \texttt{mult\_5\_is\_correct} é o nome do teorema, e
\emph{Proof/Qed} delimita a prova.  A ferramenta disponibliza uma maneira de
visualizar os estados da prova durante o processo. Introduzimos um natural
arbitrário para começar a prova, com o comando \texttt{intros n}. Após isto,
realizamos uma prova por indução com o comando \texttt{induction n}, que divide
a prova em dois subcasos. O primeiro corresponde à base de indução, e é dado
por:

\begin{lstlisting}[basicstyle=\small]
    ======================== ( 1 / 2 )
    mult_5 0 = 5 * 0

\end{lstlisting}

Usamos o comando \texttt{simpl} para computar os valores de \texttt{mult\_5 0} e
\texttt{5 * 0}, tendo assim a igualdade \texttt{0 = 0}. A validade disso vem da
reflexividade da igualdade, concluindo este caso com o comando
\texttt{reflexivity}. No passo indutivo, temos o seguinte estado:


\begin{lstlisting}[basicstyle=\small]
    n : nat
    IHn : mult_5 n = 5 * n

    ======================== ( 1 / 1 )
    mult_5 (S n) = 5 * S n
\end{lstlisting}

Onde \texttt{IHn} é nossa hipótese de indução. Começamos a prova computando o
valor de \texttt{mult\_5 (S n)}, com o comando \texttt{simpl mult\_5}.
Observando a definição desta função, vemos que o a expressão será avaliada para
\texttt{S (S (S (S (S (mult\_5 n)))))}, refletido no estado da prova. Queremos
então avaliar também o resultado de \texttt{5 * S n}. Devido à definição do
operador *, a prova se torna mais fácil se comutarmos os termos \texttt{5} e
\texttt{S n} nesta expressão. Fazemos isto utilizando o lema
\texttt{mult\_comm}, pertencente às bibliotecas do sistema, com o comando
\texttt{rewrite mult\_comm}. Após isto, computamos o valor de \texttt{(S n) *
    5}, com o comando \texttt{simpl}. Temos, então, o seguinte estado:

\begin{lstlisting}[basicstyle=\small]
    n : nat
    IHn : mult_5 n = 5 * n

    ======================== ( 1 / 1 )
    S (S (S (S (S (mult_5 n))))) = S (S (S (S (S (n * 5)))))
\end{lstlisting}

Podemos finalmente usar nossa hipótese de indução! Reescrevemos o termo
\texttt{mult\_5 n} para \texttt{5 * n}, com o comando \texttt{rewrite IHn}.
Utilizamos novamente a comutatividade do operador *, tendo finalmente o seguinte
estado:

\begin{lstlisting}[basicstyle=\small]
    n : nat
    IHn : mult_5 n = 5 * n

    ======================== ( 1 / 1 )
    S (S (S (S (S (n * 5))))) = S (S (S (S (S (n * 5)))))
\end{lstlisting}

Agora temos o mesmo termo em ambos os lados da igualdade, podendo concluir a
prova com \texttt{reflexivity}.

Os conceitos apresentados nesta seção serão amplamente utilizados no trabalho.
Para um melhor entendimento do funcionamento da ferramenta, da linguagem e
teoria envolvidas, veja \cite{pierce}.


\section{O cálculo $\lambda$}

\subsection{Visão geral}

Um dos grandes desafios do início do século XX era obter uma definição 
precisa para a noção intuitiva do processo computacional. Diversos modelos foram
propostos para resolver este problema. Entre eles está o cálculo $\lambda$,
proposto por Alonzo Church \cite{lambda_first}, em 1936. Inicialmente, o cálculo
fazia parte de um sistema maior, proposto para servir como uma base
formal para o estudo das fundações da matemática. Porém, devido a
inconsistências neste sistema, Alonzo Church foi obrigado a abrir mão de seu
objetivo inicial, separou a parte utilizável do sistema e formou o que hoje
conhecemos como cálculo $\lambda$.

O grande diferencial deste cálculo está em sua expressividade, com poder
computacional equivalente ao da Máquina de Turing, e sua simplicidade,
demonstrada por sua gramática concisa e poucas regras. A ideia central deste
consiste em simular a criação e aplicação de funções. Diferentemente da noção
usual no trabalho matemático, as funções neste sistema são chamadas "anônimas",
pois são definidas tendo em vista somente seus argumentos e o resultado. Como
exemplo, uma função simples como: "$double(x) = 2*x$" \ é definida anonimamente como
"$\lambda x.\ 2*x$". É utilizada também uma notação especial para a aplicação de
funções, denotada como "$ (\lambda x.\ 2*x)$  $3$".

É importante notar que os exemplos acima não são representados exatamente desta
maneira. Como dito anteriormente, o sistema possui uma gramática simples, e
todas as noções, inclusive números e operações, devem ser definidas com base em
abstrações e aplicações. A gramática do cálculo $\lambda$ pode ser descrita
sucintamente como:

\[ \tau := x\ |\ \lambda x.\tau\ |\ \tau \tau \]

Onde $\tau$ representa um termo, e $x$ representa uma variável. Assim, um termo
do cálculo pode ser, respectivamente, uma variável, uma abstração de um termo
$\tau$ por uma variável $x$, e uma aplicação de dois termos.  

\begin{definicao}[Variável Livre]
    Dizemos que uma variável $x$ é livre em um termo $\tau$ se não está contida
    em nenhuma abstração cujo argumento é $x$. 
\end{definicao}

Como exemplo, a variável $x$ é livre em $(\lambda y.\ y)\ x$, enquanto a
variável $y$ não é.  O conjunto de variáveis livres de \emph{t} é denotado por
\emph{fv(t)}. 

\begin{definicao}
    Definimos o conjunto de variáveis livres de $t$, denotado por $fv(t)$,
    indutivamente. Na definição abaixo, $t,u$ denotam termos e $x$ denota uma
    variável.
\begin{empheq}{align*}
    fv(x)\ & = \{x\} \\
    fv(t\ u)\ & = fv(t)\ \cup\ fv(u) \\
    fv(\lambda x. t)\ & = fv(t)\setminus \{x\}
\end{empheq}
\end{definicao}

\bigskip

O processo computacional é simulado no sistema através da regra de
$\beta$-redução, definida como:

\[ (\lambda x.t)\ u \rightarrow_{\beta} t\{x/u\} \]

Note que $t\{x/u\}$ é uma \textit{meta-operação}, definida pela substituição das
ocorrências da variável $x$ no termo $t$ pelo termo $u$. Esta operação será
definida formalmente em breve.

Para facilitar o entendimento, vejamos alguns exemplos de $\lambda$-termos:

\begin{itemize}
    \item A função identidade pode ser representada pelo termo $ (\lambda x. x) $.
        É fácil ver a correspondência na seguinte redução: $ (\lambda x.x) u
    \rightarrow_\beta x \{x/u\} = u $. 
    \item A função constante pode ser representada pelo termo $ (\lambda x. M) $,
        onde M é um termo qualquer, tal que $x \notin fv(M)$.
        É fácil ver a correspondência na seguinte redução: $ (\lambda x.M) u
    \rightarrow_\beta M \{x/u\} = M $. 
    \item Por último, podemos representar uma função que recebe dois termos e
        retorna o primeiro, como $ (\lambda x. \lambda y. x)$. Sua aplicação é
        reduzida da seguinte maneira: $ ((\lambda x. \lambda y. x)\ M)\ N)
    \rightarrow_\beta ((\lambda y. x) \{x/M\} N) = (\lambda y. M) N
    \rightarrow_\beta M \{y/N\} = N$, com $x$,$y$ não ocorrendo 
    livres em M ou N.
\end{itemize}


A partir destas definições, várias propriedades sobre o sistema podem ser
estudadas. Entre elas, é importante ressaltar as noções de \textit{forma
 normal} e de \textit{confluência}:

\begin{definicao}[Forma normal]\label{def_normal}
    Um termo $t$ é dito estar em forma normal quando não existe $t'$ tal que $ t
    \rightarrow t' $.  Um termo é dito \textbf{fracamente normalizável} quando
    existe uma estratégia de redução que leva a uma forma normal. O termo é
    \textbf{fortemente normalizável} se toda estratégia leva à forma normal.
\end{definicao}

É possível demonstrar que nem todo termo possui uma forma normal. Como exemplo,
observe que $ (\lambda x.x\ x)\ (\lambda x.x\ x) \rightarrow_\beta (\lambda x.x\
x)\ (\lambda x.x\ x) $. A noção de normalização é especialmente importante, pois
indica se um termo pode ou não terminar quando for avaliado, o que é de grande
interesse no estudo de propriedades computacionais.

\begin{definicao}[Confluência]
    Um sistema de reescrita, tomando como exemplo o cálculo $\lambda$, é dito
    fracamente confluente se, para todo termo $t$, com $ t \rightarrow_\beta t' $
    e $ t \rightarrow_\beta t'' $, então deve existir um termo $u$ tal que $t'
    \rightarrow_\beta^* u$ e $t'' \rightarrow_\beta^* u$, onde
    $\rightarrow_\beta^*$ representa o fecho transitivo-reflexivo da
    $\beta$-redução.  O sistema é dito fortemente confluente se, para todo termo
    $t$ tal que $ t \rightarrow_\beta^* t' $ e $ t \rightarrow_\beta^* t'' $,
    existe um termo $u$ tal que $t' \rightarrow_\beta^* u$ e $t''
    \rightarrow_\beta^* u$. 
\end{definicao}

\begin{definicao}[$\beta$-equivalência]
    A relação de $\beta$-equivalência $\equiv_{\beta}$ é definida como a menor
    relação de equivalência que contém a relação $\rightarrow_{\beta}$. Em
    outras palavras, dizemos que dois termos $t$ e $t'$ são $\beta$-equivalentes
    se vale $t \rightarrow_{\beta}^* t'$ ou $t' \rightarrow_{\beta}^* t$.
    Podemos ver que esta definição é de fato uma equivalência, pois é transitiva
    e reflexiva, pela definição de $\rightarrow_{\beta}^*$, e simétrica, pela
    definição aqui dada.
\end{definicao}

A propriedade de confluência pode ser entendida, essencialmente, como uma
garantia que a ordem que as reduções são feitas dentro de um termo não afetam o
resultado final do processo. Ou seja, a confluência garante o determinismo do
processo computacional.


Outro ponto importante a ser mencionado é a noção de $\alpha$-equivalência de
termos. 

\begin{definicao}[$\alpha$-equivalência]
    Um termo $(\lambda x. t)$ é dito $\alpha$-equivalente a\ $(\lambda y. u)$ se
    $ t\{x/y\} = u $. Mais geralmente, dois termos são ditos
    $\alpha$-equivalentes se um pode ser obtido a partir do outro através de
    renomeamento de variáveis ligadas. É fácil ver intuitivamente que esta
    definição é uma relação de equivalência: para a reflexividade, basta fazer
    um renomeamento trivial. Para a transitivadade, basta compor os
    renomeamentos.  Para a simetria, basta fazer o renomeamento contrário, ou
    seja: $ u\{y/x\} = t $.
\end{definicao}

Esta noção captura a ideia de que a escolha do nome das
variáveis ligadas não importa em geral, sendo o real objeto de interesse a
estrutura do termo. Esta definição é útil para evitar certos problemas, como por
exemplo o de \textit{captura de variáveis livres}. No exemplo:

\[ (\lambda x.\ y)\{y/x\},\ x\ \neq\ y \]

Efetuando a substituição sem tomar o devido cuidado, teremos o termo $\lambda
x.\ x$, que representa a função identidade. Note que isto mudou completamente a
semântica do termo! O termo anterior, $\lambda x.\ y$, representava uma função
constante, que sempre é avaliada para $y$, independente do termo dado como
argumento. Aplicando a substituição, seria razoável esperar que teríamos uma
função que é sempre avaliada para a variável $x$, o que não é o caso. 

Veja que a variável $x$ na substituição não é a mesma da que está ligada na
abstração. Isto pode causar vários problemas inesperados, como, por exemplo, a
perda da normalização do termo.  Como exemplo, considere o termo $((\lambda x.\
y\ y)\ (\lambda x.\ y\ y))$. É fácil ver que este termo deveria avaliar para
$(y\ y)$. Se queremos substituir $y$ por $x$, deveríamos obter o termo $(x\ x)$.
Porém, aplicando a substituição no termo original, temos $((\lambda x.\ y\ y)\
(\lambda x.\ y\ y))\{y/x\}$, que é avaliado para $((\lambda x.\ x\ x)\ (\lambda
x.\ x\ x))$, que não possui forma normal!

Para evitar este problema, podemos renomear a variável ligada $x$, antes da
substituição, por uma variável nova, de maneira a obter um termo
$\alpha$-equivalente e podendo então realizar a substituição sem modificar a
semântica do termo. Nos exemplos anteriores:

\[ (\lambda x.\ y)\{y/x\}\ =_{\alpha} (\lambda z.\ y)\{y/x\} = (\lambda z.\ x) \]

Observe que chegamos ao resultado esperado, ou seja, a função constante que é
sempre avaliada para $x$.

\[ ((\lambda x.\ y\ y)\ (\lambda x.\ y\ y))\{y/x\} =_{\alpha} ((\lambda z.\ y\
    y)\ (\lambda z.\ y\ y))\{y/x\} \\
    = ((\lambda z.\ x\ x)\ (\lambda z.\ x\ x)) \rightarrow_{\beta} (x\ x)\]

Conseguimos, também, evitar a perda da normalização do termo.

Assim, podemos definir formalmente a operação de substituição, da seguinte
maneira:

\begin{definicao}\label{classic_subst}
    Sejam $t, u$ termos e $x$ uma variável. A substituição de $x$ por $u$ em
    $t$ é definida indutivamente na estrutura de $t$ como:
\smallskip
\begin{empheq}{align*}
    \ y\{x/u\}\ \ \ \  & =\ u,\ se\ (x = y);\ y,\ c.c \\
    \ (t'\ v)\{x/u\} \ \ \ \  & =\ (t'\{x/u\}\ v\{x/u\}) \\
    \ (\lambda y. t') \{x/u\}  \ \ \ \  & =\ (\lambda y. t'), se (x = y);  
        (\lambda y. t\{x/u\}),\ c.c. \\
\end{empheq}
\end{definicao}

Note que, no caso da abstração, se $y \in fv(u)$, devemos realizar a
$\alpha$-equivalência para preservar a semântica do termo.


\subsection{Representação de $\lambda$-termos}
\label{sub:int_lnr}

Como dito anteriormente, o cálculo $\lambda$ é usado como modelo teórico para
linguagens funcionais. A noção de $\alpha$-equivalência, apesar de útil, pode ser
muito custosa em uma implementação prática. Por este motivo, foram propostas
algumas representações diferentes de termos, de modo a evitar a necessidade do
renomeamento de variáveis. 

Uma das primeiras, e mais importantes, tentativas de resolver o problema da
$\alpha$-conversão é a notação utilizando índices de De Bruijn \cite{debruijn72}. Nela, são
utilizados números naturais para representar as variáveis. Cada número
representa a quantidade de abstrações no escopo da ocorrência da variável.
Números que ultrapassam esta quantidade representam variáveis livres. A
gramática pode ser definida como:

\[ \tau := n\ |\ \lambda \tau\ |\ \tau \tau \]

Onde $n$ representa um número natural, a partir do 1. Exemplos de termos
nesta notação incluem a identidade $(\lambda 1)$, a função constante $(\lambda
u)$, com $u$ não contendo 1 como índice livre, e um termo com índice
livre, como $((\lambda 2)\ u)$. Apesar de sua aparente praticidade de
implementação, esta notação se afasta muito da utilização do cálculo no papel.
Além disto, introduz a necessidade de se manter um contexto externo para
registrar as variáveis livres, junto com uma álgebra para lidar com tal
contexto. Para lidar com substituições utilizando a notação de de Bruijn,
devemos introduzir a noção de $i$-elevação.

\begin{definicao}[$i$-elevação \cite{ayala}] Seja $t$ um termo da gramática de de Bruijn. A
    $i$-elevação de $t$, denotada por $t^{+i}$, é definida indutivamente como:
    \begin{itemize}
        \item $(t_1\ t_2)^{+i} = (t_1^{+i}\ t_2^{+i})$
        \item $(\lambda t_1)^{+i} = \lambda (t_1^{+(i+1)})$
        \item $n^{+i} = \begin{cases}
                            n + 1   & \text{se } n > i \\
                            n       & \text{se } n \leq i
                        \end{cases}$
    \end{itemize}
    A elevação de um termo $t$ é sua $0$-elevação, e é denotada por $t^+$.
    
\end{definicao}

A definição de substituição deve ser adaptada para lidar com os índices de de
Bruijn.

\begin{definicao}[\cite{ayala}] A substituição de um termo $t$, no nível $n -
    1$, pelo termo $u$,
    denotada por $t\{n/u\}$, é definida indutivamente como:
    \begin{itemize}
        \item $(t_1\ t_2)\{n/u\} = (t_1\{n/u\}\ t_2\{n/u\})$
        \item $(\lambda t_1)\{n/u\} = \lambda t_1\{n+1/u^+\}$
        \item $m\{n/u\} = \begin{cases}
                             m - 1 & \text{se } m > n \\
                             u     & \text{se } m = n \\
                             m     & \text{se } m \leq n
                          \end{cases}$
    \end{itemize}
\end{definicao}


\smallskip
Temos então que a relação de $\beta$-redução é definida por $(\lambda t_1)\ t_2
\rightarrow_{\beta} t_1\{1/t_2\}$.
\smallskip

Como exemplo das complexidades introduzidas por esta notação, podemos observar a
representação do termo $(\lambda x.\ x\ a)\ b$, onde $a,b$ são
variáveis livres. Este termo é representado na notação de de Bruijn como:

\[ (\lambda\ 1\ 2)\ 2 \]

Junto com o contexto $[a,\ b]$, que representa as variáveis livres.  Utilizando
esse contexto, vemos que o índice 1 representa a variável $x$, pois temos apenas
uma abstração. Após isso, cada ocorrência do índice 2 representa uma variável
livre distinta que estão relacionadas, em ordem, com as variáveis no contexto.
Assim, a primeira ocorrência do índice $2$ deve ser substituída por $a$, e a
segunda deve ser substituída por $b$.

Após realizar a $\beta$-redução, o termo original é representado por $(b\ a)$.
Porém, o termo na notação da representação de de Bruijn não é representado por
$(2\ 2)$, mas sim por $(2\ 1)$, devido às manipulações efetuadas pela
substituição. Isto é necessário porque o novo termo não possui abstratores, logo
o primeiro índice para representar variáveis livres não é 2, mas 1.

Temos então, dois problemas: utilizar a notação padrão do cálculo $\lambda$,
junto com $\alpha$-equivalência, é algo custoso do ponto de vista computacional,
pois devemos sempre tomar o cuidado com captura de variáveis livres e fazer o
renomeamento destas. Por outro lado, utilizar a notação de de Bruijn também
exige cuidados, devido à necessidade de se manter um contexto externo para
representar variáveis livres e de se utilizar uma álgebra mais complexa ao
realizar substituições.

Uma solução para estes problemas é usar a \textit{locally nameless
representation}, usada para representar os $\lambda$-termos neste trabalho. Esta
representação tenta capturar o melhor de ambos os casos: não temos a necessidade
de realizar renomeamento constante de variáveis, nem precisamos lidar com um
contexto externo.

O conjunto $\Lambda_{lnr}$ de expressões na notação LNR é definido a partir da
gramática a seguir:

\[ \tau := x\ |\ n\ |\ \lambda \tau\ |\ \tau \tau \]

Como nos casos anteriores, $x$ representa uma variável; $n$ é um índice,
representado por um natural, a partir de 1; $\lambda \tau$ representa uma
abstração e $\tau \tau$ representa uma aplicação.

Os índices $n$ representam as variáveis ligadas da expressão. O valor do índice
representa a abstração a qual ele se refere, ou seja, um índice $k$ está ligado
à $k$-ésima abstração que o contém. 

Dizemos que uma expressão é um pré-termo se pertence ao conjunto $\Lambda_{lnr}$
gerado pela gramática acima. Observe que, como os índices representam as
variáveis ligadas, não é interessante a ocorrência de índices soltos, ou seja,
sem uma abstração correspondente. Por conta disto, pré-termos que possuírem
índices soltos não possuirão correspondentes na representação padrão do cálculo
$\lambda$. Definimos então a noção de termos, que serão as expressões sem
índices livres, foco de interesse no trabalho.

\begin{definicao}[Termos]
    Dizemos que um pré-termo é um termo (bem formado) se toda ocorrência de um
    índice pertence a um número correspondente de abstrações. Em outras palavras,
    um termo não possui índices soltos.
\end{definicao}

A meta-substituição deve ser adaptada para levar em conta os índices, como no
exemplo:

\[ \{1 \rightarrow t\}(\lambda\ 2) = ( \lambda (\{2 \rightarrow t\} 2) ) \]

Note que o índice a ser substituído foi incrementado quando a substituição entra
na abstração, de modo a corresponder à variável correta a ser substituída.
Precisamos, então, definir formalmente a operação.


\begin{definicao}
    Sejam $t,u$ termos; $x,y$ variáveis e $k,i$ índices.
    A operação de substituição é definida indutivamente como:
\smallskip
\begin{empheq}{align*}
    \{k \rightarrow x\} i\ \ \ \  & =\ x,\ se\ (i = k);\ i,\ c.c\\
    \{k \rightarrow x\} y\ \ \ \  & =\ y\\
    \{k \rightarrow x\} (t\ u)\ \ \ \  & =\ (\{k \rightarrow x\}t\ \{k
    \rightarrow x\}u)\\
    \{k \rightarrow x\} (\lambda  t) \ \ \ \  & =\ 
    (\lambda  \{k+1 \rightarrow x\}t)
\end{empheq}
\end{definicao}

\medskip


Esta representação foi detalhada por Arthur Charguéraud em \cite{chargueraud},
junto com provas de seu bom funcionamento e um framework para sua utilização em
Coq.  Entraremos agora em alguns detalhes do uso desta notação, descritos em
\cite{chargueraud}, já que ela tem um interesse especial neste trabalho.

Na notação usual, quando queremos estudar o corpo de uma abstração $(\lambda x.
t')$, podemos trabalhar diretamente com o termo $t'$. Porém, nesta nova
representação, a abstração tem a forma $(\lambda\ t')$, e é necessário que seja
fornecida uma variável $x$, já que $t'$ não é um termo, em geral. Esta operação
é chamada \emph{abrir o termo} $t'$ com $x$ e será representada por $t'^{x}$. Mais
precisamente, a abertura do termo $(\lambda\ t')$ cria uma cópia de $t'$ onde todas
as ocorrências do índice ligado à abstração mais externa são trocados pela
variável $x$. Como exemplo, abrir a abstração $(\lambda (0\ y))$ com $x$ nos dá
o termo $(x\ y)$. A operação de abrir o termo deve ajustar o índice a ser mudado
à medida que entra no termo. Assim, podemos usar a já definida operação de
substituição, diretamente com a variável $x$, para realizar a abertura. Temos,
então, $t'^{x} = t'\{0 \rightarrow x\}$.

Similarmente, podemos abstrair todas as ocorrências de uma variável $x$ no termo
$t'$, construindo então o termo $(\lambda x. t')$. Com a nova notação, é
necessário definir uma operação que substitui todas as ocorrências de $x$ pelo
índice 0, antes de adicionar a abstração. Esse processo é chamado \emph{fechar o
    termo}, representado por $ ^{\textbackslash x}t'$. Assim, para construir a
abstração de maneira equivalente, fazemos $(\lambda ^{\textbackslash x}t')$. 

\begin{definicao}
    Sejam $t$ um termo, $x$ uma variável e $k$ um índice.
    Definimos indutivamente a substituição das ocorrências da variável $x$ em
    $t$ pelo índice $k$, denotada por $\{k \leftarrow x\}t$, como a seguir:
    
\begin{empheq}{align*}
    \{k \leftarrow x\} i\ \ \ \  & =\ i\\
    \{k \leftarrow x\} y\ \ \ \  & =\ \ k,\ se\ (x = y);\ y,\ c.c.\\
    \{k \leftarrow x\} (t\ u)\ \ \ \  & =\ (\{k \leftarrow x\}t\ \{k
    \leftarrow x\}u)\\
    \{k \leftarrow x\} (\lambda t) \ \ \ \  & =\ 
    (\lambda \{k+1 \leftarrow x\}t)
\end{empheq}
\end{definicao}

Podemos, então, definir a operação de fechamento como $ ^{\textbackslash x}t
= \{0 \leftarrow x\}t$.

Como dito anteriormente, esta representação possui termos que contém
\emph{índices livres}, que não possuem correspondentes no sistema original, e
não são nosso objeto de interesse. A seguir, chamaremos um termo sem índices
livres, ou seja, um termo bem formado, de \emph{localmente fechado}.

Existem duas maneiras de conferir se um termo é localmente fechado. A primeira
consiste em percorrer a estrutura do termo, abrindo cada abstração com uma nova
variável. Desta maneira, se o termo for de fato fechado, nunca encontraremos um
índice. A segunda abordagem consiste em analizar diretamente os índices do termo,
checando, para cada um deles, se o seu valor é menor ou igual ao número de
abstrações que o contêm.

A primeira opção dá lugar a uma definição natural de um predicado, denotado por
$lc\ t$ indicando que o termo é localmente fechado. Com apenas três regras
de inferência, podemos facilmente fazer uma análise mais formal da propriedade
de ser localmente fechado, sendo bastante útil em provas.

\begin{definicao}[Localmente fechado]\label{def_lc}
    Sejam $t, t1, t2$ termos, $x$ uma variável e $L$ um conjunto finito de
    variáveis. Dizemos que um termo é localmente fechado se não possui índices
    livres. Formalmente, isto é definido através do predicado $lc$, definido
    pelas regras de inferência abaixo.

\begin{mathpar} 
    \inferrule*[Right=lc\_fvar]{  }
    {lc(x)}
    \and
    \inferrule*[Right=lc\_app]{lc\ t1 \\ lc\ t2}
    {lc(t1\ t2)}
    \and
    \inferrule*[Right=lc\_abs]{\forall x \notin L,\ lc\ (t^{x})}
    {lc(\lambda. t)}
\end{mathpar}
\end{definicao}

A premissa $\forall x \notin L$ no caso da abstração captura a ideia de $x$
ser uma variável nova, pois podemos tomar o conjunto L, sempre finito, como
sendo o conjunto de variáveis já usadas e, assim, sempre ter uma escolha nova de
$x$.

A segunda abordagem tem um caráter mais naturalmente computacional, dando lugar
a uma função recursiva para conferir se um termo é localmente fechado. Tal
função vai navegando pelo termo, entrando em seus subtermos, guardando um
contador. Quando entrar em uma abstração, a função incrementa tal contador. Ao
encontrar um índice, basta conferir se ele é menor que o contador. Assim, a
função pode ser definida como a seguir.

\begin{definicao}\label{def_lc_at}
    O predicado binário $lc\_at$ que recebe um índice $k$ e um pré-termo $t$
    como argumentos é definido indutivamente na estrutura de $t$, como segue:
    
\begin{empheq}{align*}
    lc\_at\ k\ (i)\ \ \ &=\ i<k \\ 
    lc\_at\ k\ (x)\ \ \ &=\ \textbf{True} \\ 
    lc\_at\ k\ (t1\ t2)\ \ \ &=\ (lc\_at\ k\ t1)\ \&\ (lc\_at\ k\ t2) \\ 
    lc\_at\ k\ (\lambda t1)\ \ \ &=\ (lc\_at\ k + 1\ t1)
\end{empheq}
\end{definicao}

\medskip

Dizemos que o termo $t$ é localmente fechado se a função $lc\_at\ 0\ 
t$ retorna \textbf{True}.  Não é difícil provar a equivalência de ambas as
definições, ou seja, que vale $lc\ t\ \iff\ (lc\_at\ 0\ t\ =\ \textbf{True})$.
Para isto, precisaremos do seguinte lema, que é bem intuitivo:

\begin{lema}\label{lema_lc_open}
    Sejam \ $t$ um pré-termo e $x$ uma variável. Então vale 
    $(lc\_at\ k\ \{k \rightarrow x\}t) \iff (lc\_at\ (S\ k)\ t)$, para todo $k
    \in \mathbb{N}$.
\end{lema}

\begin{teorema} \label{teo:lc_lc_at}
    Seja $t$ um pré-termo. Vale ($lc\ t$) se, e somente se $(lc\_at\
    0\ t\ =\ \textbf{True})$.
\end{teorema}

\begin{proof} 
    $ $\par\nobreak\ignorespaces
\begin{itemize}
    \item[($\Rightarrow$)] Indução no predicado $lc$. O único
        subcaso que não sai imediatamente é o da abstração, que pode ser
        facilmente resolvido se observarmos que um termo $\{k \rightarrow x\}t$
        é fechado a um nível k se, e somente se, $t$ é fechado a nível k + 1,
        como visto no Lema \ref{lema_lc_open}.
    \item[($\Leftarrow$)] Indução na estrutura do termo $t$.
        Novamente, o caso da abstração merece um cuidado especial, mas ainda sai
        de maneira simples, escolhendo o conjunto L referenciado no construtor
        de $lc$ como sendo exatamente o conjunto de variáveis livres de $t$.
        Temos então, como hipótese, que vale $lc\_at\ 1\ t'$, onde $t'$ é o
        corpo da abstração, e queremos provar $(lc\ t'^x)$, para algum $x \notin
        fv(t')$. Basta então usar novamente o Lema \ref{lema_lc_open} para
        concluir a prova.
\end{itemize}
\end{proof}

Estas definições serão extremamente importantes ao decorrer do trabalho e podem
ser citadas com frequência. Em especial, a definição de localmente fechado,
correspondente à noção de termo bem formado, é essencial, pois são estes os
termos que possuem correspondentes no cálculo $\lambda$.

Vale a pena ressaltar duas outras equivalências, referentes às noções de
abertura e fechamento de termos. Temos:

\begin{lema}
    Seja $t$ um termo e $x$ uma variável. Então $^{\setminus x}(t^{x})\ =\ t,\ se\ x\
    \notin\ fv(t) $
\end{lema}
\begin{lema}
    Seja $t$ um termo e $x$ uma variável. Então $(^{\setminus x}t)^{x}\ =\ t,\ se\
    vale\ (lc\ t)$ 
\end{lema}

Para mais informações a respeito do cálculo $\lambda$, veja \cite{barendregt}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\



\section{Substituições explícitas}

\subsection{Motivação e histórico}

Sabemos que a ordem em que as reduções são feitas não altera a forma normal do
termo, mas isto não significa que não existem vantagens em se adotar certas
estratégias na normalização. 

Na implementação de linguagens de programação, a substituição muitas vezes é
"atrasada", de modo a evitar computações desnecessárias. Para aproximar o modelo
teórico de seu correspondente prático, podemos tentar fracionar a operação de
substituição em partes mais simples, de maneira a permitir uma manipulação simbólica
mais precisa. \cite{levy1999}

Além disto, separar a operação de substituição em partes mais simples pode auxiliar
no estudo de propriedades do próprio cálculo $\lambda$. Uma estratégia comum
\cite{ben_cbv, ben_beta} no estudo de propriedades do cálculo, referentes às
substituições, é analisar o problema em uma versão estendida do cálculo
$\lambda$, que possui um formalismo sintático representando as substituições,
permitindo um controle mais preciso. Demonstrada a propriedade no novo
sistema estendido, basta mostrar que ela é preservada entre os cálculos.

Por este motivo, existem várias tentativas de se formalizar a noção de
substituição, dando então espaço para o formalismo conhecido como
\textit{substituição explícita}. A princípio, podemos tentar estender a
gramática de termos da seguinte maneira:

\[ \tau := x\ |\ \lambda x.\tau\ |\ \tau \tau\ |\ \tau[x/\tau]\ \]

Podemos então espelhar o funcionamento da meta-substituição através de regras de
redução no novo cálculo, gerando o sistema conhecido como $\lambda$x.
\cite{lins86, rose92, bloo95}

\begin{table}[h]
\begin{empheq}[box=\fbox]{align*}
    (\lambda x.\ t)\ u\ \ \ &\rightarrow\ t[x/u] \\
    x[x/u]\ \ \             &\rightarrow\ u \\
    y[x/u]\ \ \             &\rightarrow\ y,\ se\ x\ \neq\ y \\
    (t\ u)[x/v]\ \ \        &\rightarrow\ t[x/v]\ u[x/v] \\
    (\lambda y.\ u)[x/v]\ \ &\rightarrow\ (\lambda y.\ u[x/v])
\end{empheq}
    \caption{Regras do sistema $\lambda$x}
\end{table}

O sistema $\lambda$x corresponde ao comportamento mínimo que se espera de um
cálculo com substituições explícitas. Porém, existem outras propriedades
interessantes que podem ser adicionadas ao sistema e, em consequência disto,
vários outros modelos foram propostos, como o $\lambda_\sigma$ \cite{hl89},
$\lambda_{ws}$ \cite{dg01},
$\lambda$lxr \cite{kes07}, entre outros. 

Um problema que pode acontecer em sistemas com substituição explícita é a perda
da preservação da normalização forte (\textbf{PSN}). \cite{mellies, Gu99}

\begin{definicao}[PSN]
    Seja $\lambda$z uma extensão do cálculo $\lambda$. Dizemos que $\lambda z$
    preserva a normalização forte se, para todo $\lambda$-termo fortemente
    normalizável (Definição \ref{def_normal}), seu correspondente em
    $\lambda$z também é fortemente normalizável nesta extensão.
\end{definicao}

Este tipo de problema é especialmente comum em cálculos com substituições
explícitas que possuem a propriedade de composição de substituições.
Essencialmente, dado um termo $t[x/u][y/v]$, podemos compor as duas
substituições, de maneira a reduzir a segunda substituição antes da primeira.
Como resultado, teríamos o termo $t[y/v][x/u[y/v]]$. 

Várias estratégias são usadas para se tentar garantir a propriedade \textbf{PSN}
do sistema, como utilização de marcas em termos, restrição de composições ou
reduções dentro de substituições explícitas, definições de classes de
equivalências, entre outros. Para uma visão geral do histórico de cálculos de
substituições explícitas, veja \cite{delia}.

%A seguir, veremos um sistema que propõe uma maneira de se compor tais
%substituições sem perder a propriedade \textbf{PSN}. Este sistema será o foco
%deste trabalho, e utilizaremos o assistente de provas Coq para formalizar certas
%propriedades essenciais deste.

A seguir, veremos um sistema que propõe uma maneira de se compor tais
substituições sem perder a propriedade \textbf{PSN}, o chamado $\lambda ex$. O
foco deste trabalho será iniciar a formalização da propriedade \textbf{IE},
chave para a prova da propriedade \textbf{PSN} deste sistema.  Para isto,
\emph{marcaremos} algumas substituições explícitas e iremos definir duas outras
reduções, de modo a controlar melhor as interações de termos com substituições
explícitas. Por fim, mostraremos a equivalência destas novas reduções com a
regra principal do sistema $\lambda ex$.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

