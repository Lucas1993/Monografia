\chapter{Introdução}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{O assistente de provas Coq} 
\subsection{Motivação}

Assistentes de provas são sistemas computacionais que permitem aos usuários
especificar teorias e provar propriedades destas em um computador. Neles, o
usuário pode construir toda sua teoria matemática em uma linguagem em que o
sistema seja capaz de verificar sua correção. Ou seja, a principal motivação por
trás de um assistente de prova é verificar formalmente as propriedades de uma
teoria. Apesar de já existir um processo humano de verificação, muitas vezes
ocorrem erros neste processo, e provas que foram aceitas numa primeira avaliação
são descobertas problemáticas algum tempo depois. Como exemplo, podemos citar o
teorema das quatro cores \cite{four_colour}, que desafiou matemáticos por anos e
foram apresentadas falsas provas diversas vezes. Este teorema foi provado em
2008, no assistente de prova  Coq, estabelecendo, assim, a sua correção.

Mas, então, o que exatamente significa uma prova? Uma prova normalmente é
definida como o processo de se estabelecer a validade de alguma afirmação. Na
matemática, as provas costumam exigir uma clareza e rigor mais extremo, de modo
a se tornar indiscutível quando analizada com cuidado. Porém, matemáticos são
humanos e, infelizmente, cometem erros. Com isto em mente, foi definida uma
noção ainda mais forte de prova, chamada \emph{prova formal}.

Uma prova formal é uma sequência finita de fórmulas lógicas tal que cada uma
delas ou é um axioma, uma suposição ou é derivada diretamente das sentenças
anteriores através das chamadas regras de inferência. A vantagem do rigor das
provas formais é que conferí-la se torna um processo muito mais simples, sendo
necessário apenas confirmar de onde vem cada uma das sentenças.

Por este motivo, provas formais são comumente construídas e verificadas pelos
assistentes de prova. Ao utilizar a linguagem do assistente, ele aos poucos
constrói a sequência de sentenças e simultaneamente checa sua validade. Porém,
isto gera outra dúvida: Por que confiar nos assistentes de prova?


\begin{description}
    \item[Lógica do assistente:] Os assistentes de prova em geral possuem uma
        teoria forte no qual são baseados. Em geral, existe um sistema
        matemático independente de implementação que pode ser estudado e
        verificado anteriormente.
    \item[Checagem do assitente:] O assistente em si é, também, um programa. Assim,
        podemos analizar seus algoritmos, demonstrar que só é possível provar
        teoremas derivados no sistema lógico interno e testar seu funcionamento
        como um programa normal.
    \item[Critério de De Bruijn:] O critério de de Bruijn afirma que a correção
        de um sistema deve ser garantida por um verificador \emph{pequeno}
        \cite{reek}. Em outras palavras, deve haver um \emph{kernel} pelo qual
        todas as fórmulas passam. Assim, se torna mais fácil estabelecer a
        confiabilidade do sistema, pois podemos verificar o kernel
        separadamente. Nem todos os assistentes de prova passam neste critério,
        como visto na Tabela \ref{table:dbj_crit}.
\end{description}

\begin{table}[h]
\centering
\caption{Relação entre assistentes de prova e o critério de de Bruijn \cite{freek}}
\label{table:dbj_crit}
\begin{tabular}{l|c}
              & \multicolumn{1}{l}{Critério de de Bruijn} \\ \hline
HOL           & $\bullet$                                 \\
Mizar         & \multicolumn{1}{l}{}                      \\
PVS           & \multicolumn{1}{l}{}                      \\ 
Coq           & $\bullet$                                 \\
Otter/Ivy     & $\bullet$                                 \\
Isabelle/Isar & $\bullet$                                 \\
Alfa/Agda     & $\bullet$                                 \\
ACL2          &                                           \\
PhoX          & $\bullet$                                 \\
IMPS          &                                           \\
Metamath      & $\bullet$                                 \\
Theorema      &                                           \\
Lego          & $\bullet$                                 \\
NuPRL         &                                           \\
$\Omega$mega  & $\bullet$                                        
\end{tabular}
\end{table}


Recentemente, existe um grande número de matemáticos interessados em assistentes
de prova, buscando construir uma teoria consistente para o uso destes e
produzindo o software necessário para facilitar seu uso. Em especial, um dos
assistentes com maior uso é o chamado Coq, a ser apresentado a seguir.

Para uma visão geral sobre o histórico e uso de assistentes de prova, veja
\cite{proof_assist}. 

\subsection{A ferramenta}

Neste trabalho, usaremos o Coq, um assistente de provas que está em
desenvolvimento desde 1983, em vários institutos de pesquisa franceses. O Coq
provê um rico ambiente para o desenvolvimento de um raciocínio formal checado
automaticamente. O núcleo do sistema é um checador de provas simples que garante
que apenas passos válidos de dedução são efetuados. Além deste núcleo, o
ambiente provê diversas táticas para facilitar a construções de provas, junto
com uma vasta biblioteca de definições e teoremas comuns.

A ferramenta vem acompanhada de uma linguagem de programação funcional, com
tipos dependentes. É através desta linguagem que podemos criar as definições e
provar os lemas de nossa teoria. Ela é baseada no Cálculo de Construções
Indutivas \cite{coquand}, uma extensão do cálculo $\lambda$ que serve como modelo
teórico para o sistema. O processo de se verificar a correção de uma prova em
Coq se reduz ao problema de \emph{checagem de tipos}. A seguir, será feita uma
introdução à sintaxe e o funcionamento da ferramenta, baseada em tutoriais
disponibilizados na página oficial do sistema, em \cite{coq} e \cite{coq2}.


Os objetos de Coq podem ser divididos em duas categorias, \emph{Prop} e
\emph{Type}. A categoria \emph{Prop} é a das proposições bem formadas. Um
exemplo de proposição na linguagem seria:

\bigskip
\coqdockw{\ensuremath{\forall}} \coqdocvar{A} \coqdocvar{B} : \coqdockw{Prop},
\coqdocvar{A} \ensuremath{\rightarrow} (\coqdocvar{A} \ensuremath{\lor}
\coqdocvar{B}).\coqdoceol
\bigskip

Predicados podem ser definidos indutivamente, como a seguir.

\bigskip \coqdockw{Inductive} \coqdocvar{even} : \coqdocvar{N}
\ensuremath{\rightarrow} \coqdockw{Prop} :=\coqdoceol 
\coqdocindent{2.00em}\ensuremath{|} \coqdocvar{even\_0} : \coqdocvar{even} 0\coqdoceol
\coqdocindent{2.00em}\ensuremath{|} \coqdocvar{even\_S} \coqdocvar{n} :
\coqdocvar{odd} \coqdocvar{n} \ensuremath{\rightarrow} \coqdocvar{even}
(\coqdocvar{n} + 1)\coqdoceol \coqdockw{with} \coqdocvar{odd} :
\coqdocvar{N} \ensuremath{\rightarrow} \coqdockw{Prop} :=\coqdoceol
\coqdocindent{2.00em}\ensuremath{|} \coqdocvar{odd\_S} \coqdocvar{n} :
\coqdocvar{even} \coqdocvar{n} \ensuremath{\rightarrow} \coqdocvar{odd}
(\coqdocvar{n} + 1).\coqdoceol \bigskip

Predicados também podem ser feitos como definições diretas, como:

\bigskip
\coqdockw{Definition} \coqdocvar{sqr} (\coqdocvar{x} : \coqdocvar{N}) :=
\coqdoctac{\ensuremath{\exists}} \coqdocvar{z}, \coqdocvar{z}
\ensuremath{\times} \coqdocvar{z} = \coqdocvar{x}.\coqdoceol
\bigskip

Assim, podemos utilizar estes predicados como propriedades de algum objeto,
provando algo como \emph{even(2)} ou \emph{sqr(4)}.

\emph{Type} é a categoria de estruturas matemáticas e estruturas de dados.
Alguns exemplos de tipos são:

\bigskip
\coqdocvar{Z} \ensuremath{\times} \coqdocvar{Z} \ensuremath{\rightarrow} \coqdocvar{Z}
\bigskip

Tipos também podem ser definidos indutivamente:

\bigskip
\coqdockw{Inductive} \coqdocvar{nat} : \coqdockw{Set} :=\coqdoceol
\coqdocindent{2.00em} \ensuremath{|} 0 : \coqdocvar{nat}\coqdoceol 
\coqdocindent{2.00em} \ensuremath{|} \coqdocvar{S} : \coqdocvar{nat} \ensuremath{\rightarrow}
\coqdocvar{nat}.\coqdoceol
\bigskip

Neste caso, elementos do tipo \emph{nat} são: 0, S ( 0 ), S ( S ( 0 ) ), etc.

O desenvolvimento de provas em Coq é feito através de uma linguagem de provas,
que permite um processo guiado pelo usuário. Ao utilizar uma tática, o usuário
está construindo os objetos de prova. Por exemplo, a tática
\texttt{intro n}, onde \texttt{n} é do tipo \texttt{nat}, constrói o termo (com um
buraco):

\bigskip
\coqdockw{fun} (\coqdocvar{n}:\coqdocvar{nat}) \ensuremath{\Rightarrow} \coqdocvar{\_}\coqdoceol
\bigskip

Onde \_\ representa um termo que irá ser construído futuramente, utilizando
outras táticas. Um exemplo de proposição simples que podemos querer provar é
\texttt{forall A : Prop, A -> A}. Provamos isto da seguinte maneira:

\bigskip
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{prova\_simples} : (\coqdockw{\ensuremath{\forall}} \coqdocvar{A} : \coqdockw{Prop}, \coqdocvar{A} \ensuremath{\rightarrow} \coqdocvar{A}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{prova\_de\_A}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{exact} \coqdocvar{prova\_de\_A}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\bigskip

Onde \emph{prova\_simples} é o nome do teorema, e \emph{Proof/Qed} delimita a
prova. A ferramenta disponibliza uma maneira de visualizar os estados da prova
durante o processo. Assim, quando terminamos o comando \texttt{intros
prova\_de\_A}, temos o seguinte estado:

\begin{lstlisting}[basicstyle=\small]
   A : Prop
   prova_de_A : A
   ============================
   A
\end{lstlisting}

Todos os elementos acima da barra horizontal são nossas \emph{hipóteses}, e
chamamos este conjunto de \emph{contexto}. Abaixo da barra está nosso objetivo
atual. Esta prova foi concluída com a tática \texttt{exact prova\_de\_A}, para
dizer que a prova é exatamente o elemento \texttt{prova\_de\_A}. 

Usando o comando \texttt{Print prova\_simples}, podemos ver o termo de prova
gerado pelas táticas.

\coqdocnoindent
\coqdocvar{prova\_simples} = \coqdockw{fun} (\coqdocvar{A} : \coqdockw{Prop})
(\coqdocvar{prova\_de\_A} : \coqdocvar{A}) \ensuremath{\Rightarrow}
\coqdocvar{prova\_de\_A} : \coqdoceol 
\coqdocindent{2.00em} \coqdockw{\ensuremath{\forall}} \coqdocvar{A} :
\coqdockw{Prop}, \coqdocvar{A} \ensuremath{\rightarrow} \coqdocvar{A}\coqdoceol
\bigskip

Para um melhor entendimento do funcionamento da ferramenta, da linguagem e
teoria envolvidas, ver \cite{pierce}.


\section{O cálculo $\lambda$}

\subsection{Visão geral}

Um dos grandes desafios do início do século XX, era obter uma definição 
precisa para a noção intuitiva do processo computacional. Diversos modelos foram
propostos para resolver este problema. Entre eles está o cálculo $\lambda$,
proposto por Alonzo Church \cite{lambda_first}, em 1936. Inicialmente, o cálculo
fazia parte de um sistema maior, proposto para servir como uma base
formal para o estudo das fundações da matemática. Porém, devido a
inconsistências neste sistema, Alonzo Church foi obrigado a abrir mão de seu
objetivo inicial, separou a parte utilizável do sistema e formou o que hoje
conhecemos como cálculo $\lambda$.

O grande diferencial deste cálculo está em sua expressividade, com poder
computacional equivalente ao da Máquina de Turing, e sua simplicidade,
demonstrada por sua gramática concisa e poucas regras. A ideia central deste
consiste em simular a criação e aplicação de funções. Diferentemente da noção
usual no trabalho matemático, as funções neste sistema são chamadas "anônimas",
pois são definidas tendo em vista somente seus argumentos e o resultado. Como
exemplo, uma função simples como: "$double(x) = 2*x$" \ é definida anonimamente como
"$\lambda x.\ 2*x$". É utilizada também uma notação especial para a aplicação de
funções, denotada como "$ (\lambda x.\ 2*x)$  $3$".

É importante notar que os exemplos acima não são representados exatamente desta
maneira. Como dito anteriormente, o sistema possui uma gramática simples, e
todas as noções, inclusive números e operações, devem ser definidas com base em
abstrações e aplicações. A gramática do cálculo $\lambda$ pode ser descrita
sucintamente como:

\[ \tau := x\ |\ \lambda x.\tau\ |\ \tau \tau \]

Onde $\tau$ representa um termo, e $x$ representa uma variável. Assim, um termo
do cálculo pode ser, respectivamente, uma variável, uma abstração de um termo
$\tau$ por uma variável $x$, e uma aplicação de dois termos.  

\begin{definicao}[Variável Livre]
    Dizemos que uma variável $x$ é livre em um termo $\tau$ se não está contida
    em nenhuma abstração cujo argumento é $x$. 
\end{definicao}

Como exemplo, a variável $x$ é livre em $(\lambda y.\ y)\ x$, enquanto a
variável $y$ não é.  O conjunto de variáveis livres de \emph{t} é denotado por
\emph{fv(t)}. 

\begin{definicao}
    Definimos o conjunto de variáveis livres de $t$, denotado por $fv(t)$,
    indutivamente. Na definição abaixo, $t,u$ denotam termos e $x$ denota uma
    variável.
\begin{empheq}{align*}
    fv(x)\ & \equiv \{x\} \\
    fv(t\ u)\ & \equiv\ fv(t)\ \cup\ fv(u) \\
    fv(\lambda x. t)\ & \equiv\ fv(t)\setminus \{x\}
\end{empheq}
\end{definicao}

\bigskip

O processo computacional é simulado no sistema através da regra de
$\beta$-redução, definida como:

\[ (\lambda x.t)\ u \rightarrow_{\beta} t\{x/u\} \]

Note que \emph{t\{x/u\}} é uma \textit{meta-operação}, definida pela substituição das
ocorrências da variável $x$ no termo $t$ pelo termo $u$.


\begin{definicao}\label{classic_subst}
    Sejam $t, u, v$ termos; $x,y$ variáveis e $k,i$ índices.
    A operação de substituição é definida indutivamente como:
\smallskip
\begin{empheq}{align*}
    \ y\{x/u\}\ \ \ \  & \equiv\ u,\ se\ (x = y);\ y,\ c.c \\
    \ (t\ v)\{x/u\} \ \ \ \  & \equiv\ (t\{x/u\}\ v\{x/u\}) \\
    \ (\lambda y. t) \{x/u\}  \ \ \ \  & \equiv\ (\lambda y. t), se (x = y);  
        (\lambda y. t\{x/u\}),\ c.c. \\
\end{empheq}
\end{definicao}

A seguir, alguns exemplos de $\lambda$-termos.

\begin{itemize}
    \item A função identidade pode ser representada pelo termo $ (\lambda x. x) $.
        É fácil ver a correspondência na seguinte redução: $ (\lambda x.x) u
    \rightarrow_\beta x \{x/u\} \rightarrow u $. 
    \item A função constante pode ser representada pelo termo $ (\lambda x. M) $,
        onde M é um termo qualquer, tal que $x \notin fv(M)$.
        É fácil ver a correspondência na seguinte redução: $ (\lambda x.M) u
    \rightarrow_\beta M \{x/u\} \rightarrow M $. 
    \item Por último, podemos representar uma função que recebe dois termos e
        retorna o primeiro, como $ (\lambda x. \lambda y. x)$. Sua aplicação é
        reduzida da seguinte maneira: $ ((\lambda x. \lambda y. x)\ M)\ N)
    \rightarrow_\beta ((\lambda y. x) \{x/M\} N) \rightarrow (\lambda y. M) N
    \rightarrow_\beta M \{y/N\} \rightarrow N$, com $x$,$y$ não ocorrendo 
    livres em M ou N.
\end{itemize}



A partir destas definições, várias propriedades sobre o sistema podem ser
estudadas. Entre elas, é importante ressaltar as noções de \textit{forma
 normal} e de \textit{confluência}:

\begin{definicao}[Forma normal]
    Um termo $t$ é dito estar em forma normal quando não existe $t'$ tal que $ t
    \rightarrow t' $.  Um termo é dito \textbf{normalizável} quando existe uma
    estratégia de redução que leva a uma forma normal. O termo é
    \textbf{fortemente normalizável} se toda estratégia leva à forma normal. 
\end{definicao}

É possível demonstrar que nem todo termo que pode ser expressado no sistema
possui uma forma normal. Como exemplo, observe que $ (\lambda x.x\ x)\ (\lambda
x.x\ x) \rightarrow_\beta (\lambda x.x\ x)\ (\lambda x.x\ x) $. A noção de
normalização é especialmente importante, pois indica se um termo pode ou não
terminar quando for avaliado, o que é de grande interesse no estudo
de propriedades computacionais.

\begin{definicao}[Confluência]
    Um sistema de reescrita, tomando como exemplo o cálculo $\lambda$, é dito
    fracamente confluente se, para todo termo $t$, se $ t \rightarrow_\beta t' $
    e $ t \rightarrow_\beta t'' $, então deve existir um termo $u$ tal que $t'
    \rightarrow_\beta^* u$ e $t'' \rightarrow_\beta^* u$, onde
    $\rightarrow_\beta^*$ representa zero ou mais passos da $\beta$-redução.  O
    sistema é dito fortemente confluente se, para todo termo $t$ tal que $ t
    \rightarrow_\beta^* t' $ e $ t \rightarrow_\beta^* t'' $, deve existir um
    termo $u$ tal que $t' \rightarrow_\beta^* u$ e $t'' \rightarrow_\beta^*$ em
    zero ou mais passos da $\beta$-redução. Neste caso, os termos $t'$ e $t''$
    são ditos \textit{$\beta$-equivalentes}.  
\end{definicao}

A propriedade de confluência pode ser entendida, essencialmente, como uma
garantia que a ordem que as reduções são feitas dentro de um termo não afetam o
resultado final do processo. Ou seja, a confluência garante o determinismo do
processo computacional.


Outro ponto importante a ser mencionado é a noção de $\alpha$-equivalência de
termos. 

\begin{definicao}[$\alpha$-equivalência]
    Um termo $(\lambda x. t)$ é dito $\alpha$-equivalente a\ $(\lambda y. u)$ se
    $ t\{x/y\} = u $. Mais geralmente, dois termos são ditos
    $\alpha$-equivalentes se um pode ser obtido a partir do outro através de
    renomeamento de variáveis ligadas.
\end{definicao}

Esta noção captura a ideia de que a escolha do nome das
variáveis ligadas não importa em geral, sendo o real objeto de interesse a
estrutura do termo. Esta definição é útil para evitar certos problemas, como por
exemplo o de \textit{captura de variáveis livres}. No exemplo:

\[ (\lambda x.\ y)\{y/x\},\ x\ \neq\ y \]

Efetuando a substituição como visto na Definição \cite{classic_subst}, teremos o
termo $\lambda x.\ x$, que representa a função identidade. Note que isto mudou
completamente a semântica do termo! O termo anterior, $\lambda x.\ y$,
representava uma função constante, que sempre é avaliada para $y$, independente
do termo dado como argumento. Aplicando a substituição, seria razoável esperar
que teríamos uma função que é sempre avaliada para a variável $x$, o que não é o
caso. 

Veja que a variável $x$ na substituição não é a mesma da que está ligada na
abstração. Isto pode causar vários problemas inesperados, como, por exemplo, a
perda da normalização do termo.  Como exemplo, considere o termo $((\lambda x.\
y\ y)\ (\lambda x.\ y\ y))$. É fácil ver que este termo deveria avaliar para
$(y\ y)$. Se queremos substituir $y$ por $x$, deveríamos obter o termo $(x\ x)$.
Porém, aplicando a substituição no termo original, temos $((\lambda x.\ y\ y)\
(\lambda x.\ y\ y))\{y/x\}$, que é avaliado para $((\lambda x.\ x\ x)\ (\lambda
x.\ x\ x))$, que não possui forma normal!

Para evitar este problema, podemos renomear a variável ligada $x$, antes da
substituição, por uma variável nova, de maneira a obter um termo
$\alpha$-equivalente e podendo então realizar a substituição sem modificar a
semântica do termo. Nos exemplos anteriores:

\[ (\lambda x.\ y)\{y/x\}\ =_{\alpha} (\lambda z.\ y)\{y/x\} = (\lambda z.\ x) \]

Observe que chegamos ao resultado esperado, ou seja, a função constante que é
sempre avaliada para $x$.

\[ ((\lambda x.\ y\ y)\ (\lambda x.\ y\ y))\{y/x\} =_{\alpha} ((\lambda z.\ y\
    y)\ (\lambda z.\ y\ y))\{y/x\} \\
    = ((\lambda z.\ x\ x)\ (\lambda z.\ x\ x)) \rightarrow_{\beta} (x\ x)\]

Observe que conseguimos evitar a perda da normalização do termo.


\subsection{Representação de $\lambda$-termos}
\label{sub:int_lnr}

Como dito anteriormente, o cálculo $\lambda$ é usado como modelo teórico para
linguagens funcionais. A noção de $\alpha$-equivalência, apesar de útil, pode ser
muito custosa em uma implementação prática. Por este motivo, foram propostas
algumas representações diferentes de termos, de modo a evitar a necessidade do
renomeamento de variáveis. 

Uma das primeiras, e mais importantes, tentativas de resolver o problema da
$\alpha$-conversão é a notação utilizando índices de De Bruijn \cite{debruijn72}. Nela, são
utilizados números naturais para representar as variáveis. Cada número
representa a quantidade de abstrações no escopo da ocorrência da variávels.
Números que ultrapassam esta quantidade representam variáveis livres. A
gramática pode ser definida como:

\[ \tau := n\ |\ \lambda \tau\ |\ \tau \tau \]

Onde $n$ representa um número natural, a partir do 1. Exemplos de termos
nesta notação incluem a identidade $(\lambda. 1)$, a função constante $(\lambda.
u)$, com $u$ não contendo 1 como índice livre, e um termo com índice
livre, como $((\lambda.2)\ u)$. Apesar de sua aparente praticidade de
implementação, esta notação se afasta muito da utilização do cálculo no papel.
Além disto, introduz a necessidade de se manter um contexto externo para
registrar as variáveis livres, junto com uma álgebra para lidar com tal
contexto. Para lidar com substituições utilizando a notação de de Bruijn,
devemos introduzir a noção de $i$-elevação.

\begin{definicao}[$i$-elevação] Seja M um termo da gramática de de Bruijn. A
    $i$-elevação de M, denotada por M$^{+i}$, é definida indutivamente como:
    \begin{itemize}
        \item $(M\ N)^{+i} = (M^{+i}\ N^{+i})$
        \item $(\lambda M)^{+i} = \lambda (M^{+(i+1)})$
        \item $n^{+i} = \begin{cases}
                            n + 1   & \text{se } n > i \\
                            n       & \text{se } n \leq i
                        \end{cases}$
    \end{itemize}
    A elevação de um termo M é sua $0$-elevação, e é denotada por M$^+$.
    
\end{definicao}

A definição de substituição deve ser adaptada para lidar com os índices de de
Bruijn.

\begin{definicao} A substituição de um termo M, no nível $n - 1$, pelo termo N,
    denotada por $M\{n/N\}$, é definida indutivamente como:
    \begin{itemize}
        \item $(M_1\ M_2)\{n/N\} = (M_1\{n/N\}\ M_2\{n/N\})$
        \item $(\lambda M)\{n/N\} = \lambda M\{n+1/N^+\}$
        \item $m\{n/N\} = \begin{cases}
                             m - 1 & \text{se } m > n \\
                             N     & \text{se } m = n \\
                             m     & \text{se } m \leq n
                          \end{cases}$
    \end{itemize}
\end{definicao}


\smallskip
Temos então que a relação de $\beta$-redução é definida por $(\lambda M)\ N
\rightarrow_{\beta} M\{1/N\}$.
\smallskip

Como exemplo das complexidades introduzidas por esta notação, podemos observar a
representação do termo $(\lambda x.\ x\ a)\ b$, onde $a,b$ são
variáveis livres. Este termo é representado na notação de de Bruijn como:

\[ (\lambda\ 1\ 2)\ 3 \]

Junto com o contexto $[a,\ b]$, que representa as variáveis livres.  Utilizando
esse contexto, vemos que o índice 1 representa a variável $x$, pois temos apenas
uma abstração. Após isso, os índices 2 e 3 representam as variáveis livres, e
estão relacionadas em ordem com as variáveis no contexto.  Assim, o índice $2$
deve ser substituído por $a$, e $3$ deve ser substituído por $b$.

Após realizar a $\beta$-redução, o termo original é representado por $(b\ a)$.
Porém, o termo na notação da representação de de Bruijn não é representado por
$(3\ 2)$, mas sim por $(2\ 1)$, devido às manipulações efetuadas pela
substituição. Isto é necessário porque os novos termos não possuem abstratores,
logo o primeiro índice para representar variáveis livres não é \textit{2}, mas
\textit{1}.

Uma solução para estes problemas é usar a \textit{locally nameless
representation}, usada para representar os $\lambda$-termos neste trabalho.
O conjunto $\Lambda_{lnr}$ de expressões na notação LNR é definido a partir da
gramática a seguir:

\[ \tau := x\ |\ n\ |\ \lambda \tau\ |\ \tau \tau \]

Como nos casos anteriores, $x$ representa uma variável; $n$ é um índice,
representado por um natural, a partir de 1; $\lambda \tau$ representa uma
abstração, que não carrega nenhuma variável e $\tau \tau$ representa uma
aplicação.

Os índices $n$ representam as variáveis ligadas da expressão. O valor do índice
representa a abstração a qual ele se refere, ou seja, um índice $k$ está ligado
à $k$-ésima abstração que o contém.

\begin{definicao}[Pré-termos e termos bem formados]
    Dizemos que uma expressão é um pré-termo se pertence ao conjunto
    $\Lambda_{lnr}$ gerado pela gramática acima.
    Dizemos que um pré-termo é um termo bem formado se toda ocorrência de um
    índice pertence a um número correspondete de abstrações. Em outras palavras,
    o termo não possui índices livres.
\end{definicao}

A meta-substituição deve ser adaptada para levar em conta estes índices, como no
exemplo:

\[ (\lambda\ 2) \{1 \rightarrow t\} \Rightarrow ( \lambda (2 \{2 \rightarrow t\}) ) \]

Note que o índice a ser substituído foi incrementado quando a substituição entra
na abstração, de modo a corresponder à variável correta a ser substituída.
Precisamos, então, definir formalmente a operação.


\begin{definicao}
    Sejam $t,u$ termos; $x,y$ variáveis e $k,i$ índices.
    A operação de substituição é definida indutivamente como:
\smallskip
\begin{empheq}{align*}
    \{k \rightarrow x\} i\ \ \ \  & \equiv\ x,\ se\ (i = k);\ i,\ c.c\\
    \{k \rightarrow x\} y\ \ \ \  & \equiv\ y\\
    \{k \rightarrow x\} (t\ u)\ \ \ \  & \equiv\ (\{k \rightarrow x\}t\ \{k
    \rightarrow x\}u)\\
    \{k \rightarrow x\} (\lambda . t) \ \ \ \  & \equiv\ 
    (\lambda . \{k+1 \rightarrow x\}t)
\end{empheq}
\end{definicao}

\medskip


Esta representação foi detalhada por Arthur Charguéraud em \cite{chargueraud},
junto com provas de seu bom funcionamento e um framework para sua utilização em
Coq.  Entraremos agora em alguns detalhes do uso desta notação, descritos em
\cite{chargueraud}, já que ela tem um interesse especial neste trabalho.

Na notação usual, quando queremos estudar o corpo de uma abstração $(\lambda x.
t)$, podemos trabalhar diretamente com o termo $t$. Porém, nesta nova
representação, a abstração tem a forma $(\lambda . t)$, e é necessário que seja
fornecida uma variável $x$. Esta operação é
chamada \emph{abrir o termo} $t$ com $x$ e será representada por
$t^{x}$. Mais precisamente, a abertura do termo $(\lambda . t)$ cria uma cópia
de $t$ onde todas as ocorrências do índice ligado à abstração mais externa
são trocados pela variável $x$ Como exemplo, abrir a abstração $(\lambda.
(0\ y))$ com $x$ nos dá o termo $(x\ y)$. A operação de abrir o termo deve
ajustar o índice a ser mudado à medida que entra no termo. Assim, podemos usar a
já definida operação de substituição, diretamente com a variável $x$, para
realizar a abertura. Temos, então, $t^{x} \equiv t\{0 \rightarrow x\}$.

Similarmente, podemos querer abstrair todas as ocorrências de $x$ no termo
$t$, construindo então o termo $(\lambda x. t)$. Com a nova notação, é
necessário definir uma operação que substitui todas as ocorrências de $x$
pelo índice 0, antes de adicionar a abstração. Esse processo é chamado
\emph{fechar o termo}, representado por $ ^{\textbackslash x}t$. Assim, para
construir a abstração de maneira equivalente, fazemos $(\lambda .
^{\textbackslash x}t)$. 

\begin{definicao}
    Sejam $t,u$ termos; $x,y$ variáveis e $k,i$ índices.
    A operação de fechamento é definida indutivamente como:
    
\begin{empheq}{align*}
    \{k \leftarrow x\} i\ \ \ \  & \equiv\ i\\
    \{k \leftarrow x\} y\ \ \ \  & \equiv\ \ k,\ se\ (x = y);\ y,\ c.c.\\
    \{k \leftarrow x\} (t\ u)\ \ \ \  & \equiv\ (\{k \leftarrow x\}t\ \{k
    \leftarrow x\}u)\\
    \{k \leftarrow x\} (\lambda . t) \ \ \ \  & \equiv\ 
    (\lambda . \{k+1 \leftarrow x\}t)
\end{empheq}
\end{definicao}

Podemos, então, definir a operação de fechamento como $ ^{\textbackslash x}t
\equiv \{0 \leftarrow t\}$.

Como dito anteriormente, esta representação possui termos que contém
\emph{índices livres}. Tais termos não possuem correspondentes no sistema
original, pois os índices não estão ligados a nenhuma abstração e não
representam variáveis livres. Assim, precisamos tomar cuidado para evitar
trabalhar com termos com tais índices, já que estes não são nosso objeto de
interesse. Para isto, chamaremos um termo sem índices livres, ou seja, um termo
bem formado, de \emph{localmente fechado}.

Existem duas maneiras de conferir se um termo é localmente fechado. A primeira
consiste em percorrer a estrutura do termo, abrindo cada abstração com uma nova
variável. Desta maneira, se o termo for de fato fechado, nunca encontraremos um
índice. A segunda abordagem consiste em analizar diretamente os índices do termo,
checando, para cada um deles, se o seu valor é menor ou igual ao número de
abstrações que o contêm.

A primeira opção dá lugar a uma definição natural de um predicado, denotado por
$lc\ t$ indicando que o termo é localmente fechado. Com apenas três regras
de inferência, podemos facilmente fazer uma análise mais formal da propriedade
de ser localmente fechado, sendo bastante útil em provas.

\begin{definicao}[Localmente fechado]
    Sejam $t, t1, t2$ termos, $x$ uma variável e $L$ um conjunto finito de
    variáveis. Dizemos que um termo é localmente fechado se não possui índices
    livres. Formalmente, isto é definido através do predicado $lc$, definido
    pelas regras de inferência abaixo.

\begin{mathpar} 
    \inferrule*[Right=lc\_fvar]{  }
    {lc(x)}
    \and
    \inferrule*[Right=lc\_app]{lc\ t1 \\ lc\ t2}
    {lc(t1\ t2)}
    \and
    \inferrule*[Right=lc\_abs]{\forall x \notin L,\ lc\ (t^{x})}
    {lc(\lambda. t)}
\end{mathpar}
\end{definicao}

A premissa $\forall x \notin L$ no caso da abstração captura a ideia de $x$
ser uma variável nova, pois podemos tomar o conjunto L, sempre finito, como
sendo o conjunto de variáveis já usadas e, assim, sempre ter uma escolha nova de
$x$.

A segunda abordagem tem um caráter mais naturalmente computacional, dando lugar
a uma função recursiva para conferir se um termo é localmente fechado. Tal
função vai navegando pelo termo, entrando em seus subtermos, guardando um
contador. Quando entrar em uma abstração, a função incrementa tal contador. Ao
encontrar um índice, basta conferir se ele é menor que o contador. Assim, a
função pode ser definida como a seguir.

\begin{definicao}\label{def_lc_at}
    Sejam $t1,t2$ termos; $x,y$ variáveis e $k,i$ índices.
    A função $lc\_at$ é definida indutivamente como:
    
\begin{empheq}{align*}
    lc\_at\ k\ (i)\ \ \ &\equiv\ i<k \\ 
    lc\_at\ k\ (x)\ \ \ &\equiv\ \textbf{True} \\ 
    lc\_at\ k\ (t1\ t2)\ \ \ &\equiv\ (lc\_at\ k\ t1)\ \&\ (lc\_at\ k\ t2) \\ 
    lc\_at\ k\ (\lambda. t1)\ \ \ &\equiv\ (lc\_at\ k + 1\ t1)
\end{empheq}
\end{definicao}

\medskip

Dizemos que o termo $t$ é localmente fechado se a função $lc\_at\ 0\ 
t$ retorna \textbf{True}.  Não é difícil provar a equivalência de ambas as
definições, ou seja, que vale $lc\ t\ \iff\ (lc\_at\ 0\ t\ =\ \textbf{True})$.
Para isto, precisaremos do seguinte lema, que é bem intuitivo:

\begin{lema}\label{lema_lc_open}
    Seja \ $t$ um termo, $k$ um índice e $x$ uma variável. Então vale 
    $(lc\_at\ k\ t\{k \rightarrow x\}) \iff (lc\_at\ (S\ k)\ t)$
\end{lema}

\begin{teorema} $lc\ t\ \iff\ (lc\_at\ 0\ t\ =\ \textbf{True})$
\end{teorema}

\begin{proof} 
    $ $\par\nobreak\ignorespaces
\begin{itemize}
    \item[($\Leftarrow$)] Indução no predicado $lc$. O único
        subcaso que não sai imediatamente é o da abstração, que pode ser
        facilmente resolvido se observarmos que um termo $t\{k \rightarrow x\}$
        é fechado a um nível k se, e somente se, $t$ é fechado a nível k + 1,
        como visto no Lema \ref{lema_lc_open}.
    \item[($\Rightarrow$)] Indução na estrutura do termo $t$.
        Novamente, o caso da abstração merece um cuidado especial, mas ainda sai
        de maneira simples, escolhendo o conjunto L referenciado no construtor
        de $lc$ como sendo exatamente o conjunto de variáveis livres de $t$.
\end{itemize}
\end{proof}

Estas definições serão extremamente importantes ao decorrer do trabalho e podem
ser citadas com frequência. Em especial, a definição de localmente fechado,
correspondente à noção de termo bem formado, é essencial, pois são estes os
termos que possuem correspondentes no cálculo $\lambda$.

Vale a pena ressaltar duas outras equivalências, referentes às noções de
abertura e fechamento de termos. Temos:

\begin{lema}
    $^{\setminus x}(t^{x})\ =\ t,\ se\ x\ \notin\ fv(t) $
\end{lema}
\begin{lema}
    $(^{\setminus x}t)^{x}\ =\ t,\ se\ vale\ (lc\ t)$
\end{lema}

Para mais informações a respeito do cálculo $\lambda$, veja \cite{barendregt}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\



\section{Substituições explícitas}

\subsection{Motivação e histórico}

Sabemos que a ordem em que as reduções são feitas não altera a forma normal do
termo, mas isto não significa que não existem vantagens em se adotar certas
estratégias na normalização. Como exemplo, observe os seguintes casos:

\[ ((\lambda.\ x) t) \{0/y\} \rightarrow ((\lambda.\ x\{1/y\})\ t\{0/y\}) 
    \rightarrow ((\lambda.\ x) t') \rightarrow (x\{0/t\}) \rightarrow x
\]

\[ ((\lambda.\ x) t) \{0/y\} \rightarrow (x\{0/t\}) \{0/y\} 
    \rightarrow x \{0/y\} \rightarrow x \]

Veja que, na segunda abordagem, evitamos uma operação potencialmente custosa de
realizar uma substituição em um termo $t$ que seria imediatamente
descartado. Infelizmente, o uso da meta-operação nos impede de realizar este
tipo de manipulação, pois a substituição não faz parte da sintaxe do sistema.

Na implementação de linguagens de programação, a substituição muitas vezes é
"atrasada", de modo a evitar computações desnecessárias. Para aproximar o modelo
teórico de seu correspondente prático, podemos tentar fracionar a operação de
substituição em partes atômicas, de maneira a permitir uma manipulação simbólica
mais precisa. 

Por este motivo, várias tentativas de se formalizar a noção de substituição,
dando então espaço para o formalismo conhecido como \textit{substituição
explícita}. A princípio, podemos tentar estender a gramática de termos da
seguinte maneira:

\[ \tau := x\ |\ \lambda x.\tau\ |\ \tau \tau\ |\ \tau[x/\tau]\ \]

Podemos então espelhar o funcionamento da meta-substituição através de regras de
redução no novo cálculo, gerando o sistema conhecido como $\lambda$x.

\begin{table}[h]
\begin{empheq}[box=\fbox]{align*}
    (\lambda x.\ t)\ u\ \ \ &\rightarrow\ t[x/u] \\
    x[x/u]\ \ \             &\rightarrow\ u \\
    y[x/u]\ \ \             &\rightarrow\ y,\ se\ x\ \neq\ y \\
    (t\ u)[x/v]\ \ \        &\rightarrow\ t[x/v]\ u[x/v] \\
    (\lambda y.\ u)[x/v]\ \ &\rightarrow\ (\lambda y.\ u[x/v])
\end{empheq}
    \caption{Regras do sistema $\lambda$x}
\end{table}

O sistema $\lambda$x corresponde ao comportamento mínimo que se espera de um
cálculo com substituições explícitas. Porém, existem outras propriedades
interessantes que podem ser adicionadas ao sistema e, em consequência disto,
vários outros modelos foram propostos, como o $\lambda_\sigma$, $\lambda_{ws}$,
$\lambda$lxr, entre outros. 

Um problema que pode acontecer em sistemas com substituição explícita é a perda
da preservação da normalização forte (\textbf{PSN}), que pode ser definida como:

\begin{description}
    \item[PSN:] Se $\lambda$z é um cálculo baseado no cálculo $\lambda$, deve
        valer a seguinte afirmação. Se $t$ é um $\lambda$-termo fortemente
        normalizável, então seu correspondente em $\lambda$z também o é neste
        novo sistema.
\end{description}

Este tipo de problema é especialmente comum em cálculos de substituições
explícitas que possuem a propriedade de composição de substituições.
Essencialmente, dado um termo $t[x/u][y/v]$, podemos compor as duas
substituições, de maneira a reduzir a segunda substituição antes da primeira.
Como resultado, teríamos o termo $t[y/v][x/u[y/v]]$. 

Várias estratégias são usadas para se tentar garantir a propriedade \textbf{PSN}
do sistema, como utilização de marcas em termos, restrição de composições ou
reduções dentro de substituições explícitas, definições de classes de
equivalências, entre outros. Para uma visão geral do histórico de cálculos de
substituições explícitas, veja \cite{es_overview}.

A seguir, veremos um sistema que propõe uma maneira de se compor tais
substituições sem perder a propriedade \textbf{PSN}. Este sistema será o foco
deste trabalho, e utilizaremos o assistente de provas Coq para formalizar certas
propriedades essenciais deste.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

